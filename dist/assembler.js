"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assembler = void 0;
const builtin_1 = require("~/builtin");
const format_1 = require("~/format");
var Assembler;
(function (Assembler) {
    /**
     * Assembles a given list of syntax data into a valid Z# assembly
     * file. The output is a string that can be written directly to a
     * file with a `.iz` extension.
     *
     * @param syntaxData The list of syntax data to assemble. This is
     * generated by the parser.
     * @param scope The scope that the syntax data should be assembled
     * in. This is typically a root scope.
     * @param isMain If true, the resulting assembly file will be a
     * complete program. Otherwise, it will be a library.
     *
     * @returns A string of Z# assembly code.
     */
    function assemble(syntaxData, scope, config) {
        let content = format_1.Format.section({
            type: '.text',
            label: scope.label
        });
        let data = format_1.Format.section({
            type: '.data'
        });
        scope = builtin_1.BuiltIn.inject(scope);
        for (const _data of syntaxData) {
            content += _data.feature.toAssemblyText(_data.export, _data.scope);
            data += _data.feature.toAssemblyData(_data.export, _data.scope);
        }
        ;
        // Util.debug(scope);
        content = data + content;
        return (scope.label == 'main' ? `
#include <z.S>
/*
 * ðŸ«Ž Mooseworth is here!
 * ${format_1.Format.comment([`Author: ${config?.Project?.Author.name}`, `Contributors: ${config?.Project?.Contributors?.names.join('\t\n')}`])}
 */
` : '') + content;
    }
    Assembler.assemble = assemble;
    ;
})(Assembler || (exports.Assembler = Assembler = {}));
;
