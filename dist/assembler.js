"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assembler = void 0;
const builtin_1 = require("~/builtin");
const util_1 = require("./util");
var Assembler;
(function (Assembler) {
    /**
     * Assembles a given list of syntax data into a valid Z# assembly
     * file. The output is a string that can be written directly to a
     * file with a `.iz` extension.
     *
     * @param syntaxData The list of syntax data to assemble. This is
     * generated by the parser.
     * @param scope The scope that the syntax data should be assembled
     * in. This is typically a root scope.
     * @param isMain If true, the resulting assembly file will be a
     * complete program. Otherwise, it will be a library.
     *
     * @returns A string of Z# assembly code.
     */
    function assemble(syntaxData, scope, isMain, config) {
        let content = `
		.section .text
		#pragma section ${scope.label}
		`;
        let data = '.section .data\n';
        scope = builtin_1.BuiltIn.inject(scope);
        for (const _data of syntaxData) {
            content += _data.feature.toAssemblyText(_data.export, _data.scope);
            data += _data.feature.toAssemblyData(_data.export, _data.scope);
        }
        ;
        util_1.Util.debug(scope);
        content = data + content;
        return (isMain ? `
#include <z.S>
/*
 * ðŸ«Ž Mooseworth is here!
 ${[`Author: ${config?.Project?.Author.name}`, `Contributors: ${config?.Project?.Contributors?.names.join(', ')}`].join('\n * ')}
 */
` : '') + content;
    }
    Assembler.assemble = assemble;
    ;
})(Assembler || (exports.Assembler = Assembler = {}));
;
