"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assembler = void 0;
const format_1 = require("~/format");
const z_S_1 = __importDefault(require("~/asm/dist/z_S"));
var Assembler;
(function (Assembler) {
    /**
     * Assembles a given list of syntax data into a valid Z# assembly
     * file. The output is a string that can be written directly to a
     * file with a `.iz` extension.
     *
     * @param syntaxData The list of syntax data to assemble. This is
     * generated by the parser.
     * @param scope The scope that the syntax data should be assembled
     * in. This is typically a root scope.
     * @param isMain If true, the resulting assembly file will be a
     * complete program. Otherwise, it will be a library.
     *
     * @returns A string of Z# assembly code.
     */
    async function assemble(syntaxData, scope, config) {
        let text = format_1.Format.section.start({
            type: '.text',
            label: scope.label
        });
        let data = format_1.Format.section.start({
            type: '.data',
            label: 'data'
        });
        for (const _data of syntaxData) {
            text += await _data.feature.toAssemblyText(_data.export, _data.scope);
            data += await _data.feature.toAssemblyData(_data.export, _data.scope);
        }
        ;
        text = text + format_1.Format.section.end();
        data = data + format_1.Format.section.end();
        text = data + text;
        return (scope.label == 'main' ? `
${z_S_1.default.slice(z_S_1.default.indexOf('#pragma section legal') + '#pragma section legal'.length, z_S_1.default.indexOf('#pragma section end'))}
/**
 * ðŸ«Ž Mooseworth is here!
 * ${format_1.Format.comment([`Author: ${config?.Project?.Author.name}`, `Contributors: ${config?.Project?.Contributors?.names.join('\t\n')}`])}
 */
#pragma block ASM
#include "z.S"
` : '') + text.replace(/\n{1,2}(\s*)/gm, '\n$1') + (scope.label == 'main' ? `
#pragma block end
` : '');
    }
    Assembler.assemble = assemble;
    ;
})(Assembler || (exports.Assembler = Assembler = {}));
;
