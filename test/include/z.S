#pragma section legal
/**
 * ! READ THIS !
 *
 * # Legal statements
 *
 * This code was generated by the Z# programming system. ü´é ‚ù§Ô∏è
 *
 * Z# is an open-source project licensed under the MIT License
 * with the following restriction:
 *
 * - You may use, copy, modify, merge, publish, distribute, and sublicense
 *   this software freely, **but you may NOT sell the original software
 *   or derivative works as standalone products.**
 *
 * - This software is provided "AS IS", without warranty of any kind.
 *
 * - The Z# organization, its developers, and contributors disclaim all liability
 *   for any damages arising from the use of this software.
 *
 * - Responsibility for malicious or harmful code lies solely with the author,
 *   not with Z# or its maintainers.
 *
 * Z# is not intended to generate malicious code, but like any tool,
 * it can be misused. Use at your own risk.
 *
 * If you find Z# useful, please consider supporting the project:
 * https://zsharp.dev/donate ‚ù§Ô∏è
 */
#pragma section end

#define EVAL(x) x

#define CONCAT_2(a, b) CONCAT_IMPL(a, b)
#define CONCAT_3(a, b, c) CONCAT_IMPL(a, CONCAT_IMPL(b, c))
#define CONCAT_4(a, b, c, d) CONCAT_IMPL(CONCAT_IMPL(a, b), CONCAT_IMPL(c, d))

#define CONCAT_IMPL(a, b) a##b

/**
 * # Register usage
 *
 * Z0 - Z4  : Mnemonic control
 * Z5       : Scope
 * Z6       : Selector control
 * Z7       : Parameters
 * Z8       : Control flow
 * Z9       : Stack control
 * Z10 - Z13: Unallocated
 * Z14      : Debugger control
 * Z15      : Temporary
 */

/* Architecture mapping */

/* x86_64 (64-bit) */
#if defined(__x86_64__) || defined(__amd64__)
	# Registers
	#define RAX rax
	#define RBX rbx
	#define RCX rcx
	#define RDX rdx
	#define RSI rsi
	#define RDI rdi
	#define RSP rsp
	#define RBP rbp
	#define R8  r8
	#define R9  r9
	#define R10 r10
	#define R11 r11
	#define R12 r12
	#define R13 r13
	#define R14 r14
	#define R15 r15
	#define RIP rip

	# Mnemonics
	#define SYSCALL syscall
	#define MOV(x, y) mov x, y
	#define LDR(x, y, z) mov x, [y + z]
	#define LDL(x, y) mov x, y
	#define LEA(x, y, z) lea x, [y + z]
	#define XOR(x, y) xor x, y
	#define ADD(x, y) add x, y
	#define SUB(x, y) sub x, y
	#define IMUL(x, y) imul x, y
	#define IDIV(x) idiv x
	#define INC(x) inc x
	#define DEC(x) dec x
	#define CMP(x, y) cmp x, y
	#define TEST(x, y) test x, y
	#define JMP(x) jmp x
	#define JE(x) je x
	#define JNE(x) jne x
	#define JG(x) jg x
	#define JL(x) jl x
	#define JGE(x) jge x
	#define JLE(x) jle x
	#define CALL(x) call x
	#define RET ret
	#define PUSH(x) push x
	#define POP(x) pop x
	#define NOP nop
	#define INT(x) int x

	# Value
	#define REF(x) $x

/* ARM64 (AArch64) */
#elif defined(__aarch64__)
	# Registers
	#define RAX x0
	#define RBX x1
	#define RCX x2
	#define RDX x3
	#define RSI x4
	#define RDI x5
	#define RSP sp
	#define RBP x29
	#define R8  x8
	#define R9  x9
	#define R10 x10
	#define R11 x11
	#define R12 x12
	#define R13 x13
	#define R14 x14
	#define R15 x15
	#define RIP pc

	# Mnemonics
	#define SYSCALL svc 0
	#define MOV(x, y) mov x, y
	#define LDR(x, y, z) ldr x, [y, z]
	#define LDL(x, y) ldr x, =y
	#define LEA(x, y, z) adr x, y
	#define XOR(x, y) eor x, x, y
	#define ADD(x, y) add x, x, y
	#define SUB(x, y) sub x, x, y
	#define IMUL(x, y) mul x, x, y
	#define IDIV(x, y) sdiv x, x, y
	#define INC(x) add x, x, #1
	#define DEC(x) sub x, x, #1
	#define CMP(x, y) cmp x, y
	#define TEST(x, y) ands xzr, x, y
	#define JMP(x) b x
	#define JE(x) b.eq x
	#define JNE(x) b.ne x
	#define JG(x) b.gt x
	#define JL(x) b.lt x
	#define JGE(x) b.ge x
	#define JLE(x) b.le x
	#define CALL(x) bl x
	#define RET ret
	#define PUSH(x) str x, [sp, #-16]!
	#define POP(x) ldr x, [sp], #16
	#define NOP nop
	#define INT(x) svc x

	# Value
	#define REF(x) #EVAL(x)

#else
	#error "Unsupported architecture for register mapping"
#endif

/* Z# Virtual registers */
#define Z0  RAX
#define Z1  RBX
#define Z2  RCX
#define Z3  RDX
#define Z4  RSI
#define Z5  RDI
#define Z6  RBP
#define Z7  R8
#define Z8  R9
#define Z9  R10
#define Z10 R11
#define Z11 R12
#define Z12 R13
#define Z13 R14
#define Z14 R15

.macro SAVE_R0_R4
	PUSH (RAX)
	PUSH (RBX)
	PUSH (RCX)
	PUSH (RDX)
	PUSH (RSI)
.endm

.macro LOAD_R0_R4
	POP (RSI)
	POP (RDX)
	POP (RCX)
	POP (RBX)
	POP (RAX)
.endm

.macro SAVE_ZASM
	PUSH (RDI)
	PUSH (RSP)
	PUSH (RBP)
	PUSH (R8)
	PUSH (R9)
	PUSH (R10)
	PUSH (R11)
	PUSH (R12)
	PUSH (R13)
	PUSH (R14)
	PUSH (R15)
.endm

.macro LOAD_ZASM
	POP (R15)
	POP (R14)
	POP (R13)
	POP (R12)
	POP (R11)
	POP (R10)
	POP (R9)
	POP (R8)
	POP (RBP)
	POP (RSP)
	POP (RDI)
.endm

.macro SAVE 
	SAVE_R0_R4
	SAVE_ZASM
.endm

.macro LOAD
	LOAD_ZASM
	LOAD_R0_R4
.endm

#define WINDOWS_SYSCALL_EXIT 0
#define WINDOWS_SYSCALL_WRITE 0
#define WINDOWS_SYSCALL_READ 0
#define WINDOWS_SYSCALL_OPEN 0
#define WINDOWS_SYSCALL_CLOSE 0
#define WINDOWS_SYSCALL_FORK 0
#define WINDOWS_SYSCALL_EXECVE 0
#define WINDOWS_SYSCALL_WAIT4 0
#define WINDOWS_SYSCALL_GETPID 0
#define WINDOWS_SYSCALL_GETUID 0
#define WINDOWS_SYSCALL_GETGID 0
#define WINDOWS_SYSCALL_BRK 0
#define WINDOWS_SYSCALL_MMAP 0
#define WINDOWS_SYSCALL_MUNMAP 0
#define WINDOWS_SYSCALL_CLONE 0

#define APPLE_SYSCALL_EXIT 0x2000001
#define APPLE_SYSCALL_WRITE 0x2000004
#define APPLE_SYSCALL_READ 0x2000003
#define APPLE_SYSCALL_OPEN 0x2000005
#define APPLE_SYSCALL_CLOSE 0x2000006
#define APPLE_SYSCALL_FORK 0x2000002
#define APPLE_SYSCALL_EXECVE 0x200003b
#define APPLE_SYSCALL_WAIT4 0x2000007
#define APPLE_SYSCALL_GETPID 0x2000014
#define APPLE_SYSCALL_GETUID 0x2000018
#define APPLE_SYSCALL_GETGID 0x200001a
#define APPLE_SYSCALL_BRK 0x2000034
#define APPLE_SYSCALL_MMAP 0x20000c5
#define APPLE_SYSCALL_MUNMAP 0x2000049
#define APPLE_SYSCALL_CLONE 0x20000fa

#define UNIX_SYSCALL_EXIT 1
#define UNIX_SYSCALL_WRITE 4
#define UNIX_SYSCALL_READ 3
#define UNIX_SYSCALL_OPEN 5
#define UNIX_SYSCALL_CLOSE 6
#define UNIX_SYSCALL_FORK 2
#define UNIX_SYSCALL_EXECVE 11
#define UNIX_SYSCALL_WAIT4 7
#define UNIX_SYSCALL_GETPID 20
#define UNIX_SYSCALL_GETUID 24
#define UNIX_SYSCALL_GETGID 47
#define UNIX_SYSCALL_BRK 17
#define UNIX_SYSCALL_MMAP 90
#define UNIX_SYSCALL_MUNMAP 91
#define UNIX_SYSCALL_CLONE 120

#define LINUX_SYSCALL_EXIT 60
#define LINUX_SYSCALL_WRITE 1
#define LINUX_SYSCALL_READ 0
#define LINUX_SYSCALL_OPEN 2
#define LINUX_SYSCALL_CLOSE 3
#define LINUX_SYSCALL_FORK 57
#define LINUX_SYSCALL_EXECVE 59
#define LINUX_SYSCALL_WAIT4 61
#define LINUX_SYSCALL_GETPID 39
#define LINUX_SYSCALL_GETUID 102
#define LINUX_SYSCALL_GETGID 104
#define LINUX_SYSCALL_BRK 12
#define LINUX_SYSCALL_MMAP 9
#define LINUX_SYSCALL_MUNMAP 11
#define LINUX_SYSCALL_CLONE 56

#ifdef __WIN32
	#define TARGET "MICROSOFT/WINDOWS"
	#define SYS WINDOWS
#elif TARGET_OS_MAC
	#define TARGET "APPLE/MAC-OS"
	#define SYS APPLE
#elif TARGET_OS_IPHONE
	#define TARGET "APPLE/IPHONE"
	#define SYS APPLE
#elif __linux__
	#define TARGET "LINUX"
	#define SYS LINUX
#elif __ANDROID__
	#define TARGET "ANDROID"
	#define SYS LINUX
#elif __unix__
	#define TARGET "UNIX"
	#define SYS UNIX
#else
	#define TARGET "UNKNOWN"
	#define SYS LINUX
#endif

#define SYS_GET(x) CONCAT_2(EVAL(SYS), _##x)

# Allocate N bytes ‚Üí result in %rax
.macro MALLOC size
	SAVE_ZASM
	MOV (RAX, REF(SYS_GET(SYSCALL_MMAP))) ;// syscall number: mmap (Linux AArch64)
	MOV (RDI, REF(0))                     ;// addr = NULL
	MOV (RSI, REF(\size))                 ;// length = size
	MOV (RDX, REF(3))                     ;// PROT_READ | PROT_WRITE
	MOV (R10, REF(0x22))                  ;// MAP_ANONYMOUS | MAP_PRIVATE
	MOV (R8, REF(-1))                     ;// fd = -1
	MOV (REF(0), R9)                      ;// offset = 0
	SYSCALL
	LOAD_ZASM
.endm

# Read value at pointer ‚Üí %reg
#   ptr = register with pointer
#   reg = output register
.macro PTR_READ ptr, reg
    MOV ([\ptr], \reg)
.endm

# Write value to pointer
#   value = register with value
#   ptr = pointer register
.macro PTR_WRITE value, ptr
    MOV (\value, [\ptr])
.endm

# Store value in memory, and return a pointer to it
#   value = register with value
#   out = output register with pointer
.macro PTR_CREATE value, size, out
    SAVE_R0_R4
    MALLOC \size               ;// allocate bytes
    MOV (\value, [RAX])        ;// store value at allocated address
    MOV (RAX, \out)            ;// return pointer
    LOAD_R0_R4
.endm

.macro LEN ptr, out
	SAVE_R0_R4
	MOV (\ptr, RCX)
1:
	MOV ([RCX], RDX)
	CMP (RDX, REF(0))
	JE (2f)
	INC (RCX)
	JMP (1b)
2:
	MOV (RCX, \out)
	LOAD_R0_R4
.endm

.macro FREE ptr, size
	SAVE
	MOV (REF(11), RAX)          ;// sys_munmap
	MOV (\ptr, RDI)             ;// pointer
	MOV (REF(\size), RSI)       ;// size in bytes
	SYSCALL
	LOAD
.endm

.macro DEBUG value
	MOV (RCX, REF(\value))
	LEN \value
	SUB (RDX, RCX)
.endm

.section .text
.global _start
_start:
	

# Allocate the table itself once
.macro LAZY_LIST_INIT name, slots
    .lcomm \name, \slots * 8
.endm

# Get address of list[index] ‚Üí in %rdi
.macro LAZY_PTR_GET name, index, reg
	SAVE
	LEA (\name, \reg, RIP)
	MOV (REF(\index), RSI)
	IMUL (REF(8), RSI)
	ADD (RSI, \reg)
	LOAD
.endm

# Access item at index, allocate if null
#   name = list name
#   index = integer index
#   size = allocation size
#   reg = register for result address
.macro LAZY_BLOCK_GET name, index, size, reg
	SAVE
	LAZY_PTR_GET \name, \index, \reg
	MOV ((\reg), RSI)
	JNE (REF(1f))
	MALLOC \size
	MOV (RAX, \reg)
1:
	LDR (\reg, \reg, 0)
	LOAD
.endm

# Set value at a specific index in a lazy list
#   name = list name
#   index = integer index
#   value = value to set (in register)
.macro LAZY_BLOCK_SET name, index, value
	SAVE
	LAZY_PTR_GET \name, \index, RDI
	MOV (REF(\value), RDI)
	LOAD
.endm

# Usage: 
# STRUCT name
#   STRUCT_FIELD field_name, size
# STRUCT_END

.set STRUCT_OFFSET, 0

.macro STRUCT name
	.set \name\()_SIZE, 0
	.pushsection .data
\name:
.endm

.macro STRUCT_FIELD name, size
\name:
	.skip \size
	.set STRUCT_OFFSET, STRUCT_OFFSET + \size
.endm

.macro STRUCT_END
	.popsection
	.set STRUCT_SIZE, STRUCT_OFFSET
	.set STRUCT_OFFSET, 0
.endm

.macro ALIGN boundary
	.balign \boundary
.endm

.macro VAR id, value, out
	;// TODO
.endm

.macro FUNC name, _
	.section .text
	.global \name
\name:
.endm

.macro PARAM type, name
	# Store param info
	.quad 0x10
	.asciz "\name"
	.quad \type
.endm

.macro PARAMS_END
	.quad 0x11
.endm

.macro FUNC_END
	.quad 0xFF
.endm

.macro RETURN value
	MOV (R8, \value)
.endm

# Type initialization
.macro TYPE name
	STRUCT \name
.endm

.macro TYPE_FIELD type, name
	#if type == BYTE
		STRUCT_FIELD \name
	#endif
.endm

.macro TYPE_END
	STRUCT_END
.endm

.macro SCOPE name
	
.endm

.macro SCOPE_SET name, value
	
.endm
