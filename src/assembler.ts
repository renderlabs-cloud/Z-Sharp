import { Feature } from '~/feature';
import { Syntax } from '~/syntax';
import { official } from '~/official';
import { Project } from '~/project';
import { Util } from '~/util';
import { Format } from '~/format';
import iz_ASM from '~/asm/dist/z_S';

export namespace Assembler {
	/**
	 * Assembles a given list of syntax data into a valid Z# assembly
	 * file. The output is a string that can be written directly to a
	 * file with a `.iz` extension.
	 *
	 * @param syntaxData The list of syntax data to assemble. This is
	 * generated by the parser.
	 * @param scope The scope that the syntax data should be assembled
	 * in. This is typically a root scope.
	 * @param isMain If true, the resulting assembly file will be a
	 * complete program. Otherwise, it will be a library.
	 *
	 * @returns A string of Z# assembly code.
	 */
	export async function assemble(syntaxData: Syntax.SyntaxData[], scope: Feature.Scope, config: Project.Configuration) {
		let text = Format.section.start({
			type: '.text',
			label: scope.label
		});
		let data = Format.section.start({
			type: '.data',
			label: 'data'
		});

		for (const _data of syntaxData) {
			text += await _data.feature.toAssemblyText(_data.export, _data.scope);
			data += await _data.feature.toAssemblyData(_data.export, _data.scope);
		};
		text = text + Format.section.end();
		data = data + Format.section.end();
		text = data + text;
		return (scope.label == 'main' ? `
${iz_ASM.slice(iz_ASM.indexOf('#pragma section legal') + '#pragma section legal'.length, iz_ASM.indexOf('#pragma section end'))}
/**
 * ðŸ«Ž Mooseworth is here!
 * ${Format.comment([`Author: ${config?.Project?.Author.name}`, `Contributors: ${config?.Project?.Contributors?.names.join('\t\n')}`])}
 */
#pragma block ASM
#include "z.S"
` : '') + text.replace(/\n{1,2}(\s*)/gm, '\n$1') + (scope.label == 'main' ? `
#pragma block end
` : '');
	};
};
