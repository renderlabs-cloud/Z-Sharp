import { Feature } from '~/feature';
import { Syntax } from '~/syntax';
import { BuiltIn } from '~/builtin';
import { official } from '~/official';
import { Project } from '~/project';
import { Util } from '~/util';
import { Format } from '~/format'; 

export namespace Assembler {
	/**
	 * Assembles a given list of syntax data into a valid Z# assembly
	 * file. The output is a string that can be written directly to a
	 * file with a `.iz` extension.
	 *
	 * @param syntaxData The list of syntax data to assemble. This is
	 * generated by the parser.
	 * @param scope The scope that the syntax data should be assembled
	 * in. This is typically a root scope.
	 * @param isMain If true, the resulting assembly file will be a
	 * complete program. Otherwise, it will be a library.
	 *
	 * @returns A string of Z# assembly code.
	 */
	export function assemble(syntaxData: Syntax.SyntaxData[], scope: Feature.Scope, config: Project.Configuration) {
		let content = Format.section({
			type: '.text',
			label: scope.label
		});
		let data = Format.section({
			type: '.data'
		});


		scope = BuiltIn.inject(scope);

		for (const _data of syntaxData) {
			content += _data.feature.toAssemblyText(_data.export, _data.scope);
			data += _data.feature.toAssemblyData(_data.export, _data.scope)
		};
		// Util.debug(scope);
		content = data + content;
		return (scope.label == 'main' ? `
#include <z.S>
/*
 * ðŸ«Ž Mooseworth is here!
 * ${Format.comment([`Author: ${config?.Project?.Author.name}`, `Contributors: ${config?.Project?.Contributors?.names.join('\t\n')}`])}
 */
` : '') + content;
	};
};
