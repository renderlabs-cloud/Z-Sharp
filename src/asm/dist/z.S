// clang-format off
#pragma section legal
/**
 * ! READ THIS !
 *
 * # Legal statements
 *
 * This code was generated by the Z# programming system. ü´é ‚ù§Ô∏è
 *
 * Z# is an open-source project licensed under the MIT License
 * with the following restriction:
 *
 * - You may use, copy, modify, merge, publish, distribute, and sublicense
 *   this software freely, **but you may NOT sell the original software
 *   or derivative works as standalone products.**
 *
 * - This software is provided "AS IS", without warranty of any kind.
 *
 * - The Z# organization, its developers, and contributors disclaim all liability
 *   for any damages arising from the use of this software.
 *
 * - Responsibility for malicious or harmful code lies solely with the author,
 *   not with Z# or its maintainers.
 *
 * Z# is not intended to generate malicious code, but like any tool,
 * it can be misused. Use at your own risk.
 *
 * If you find Z# useful, please consider supporting the project:
 * https://zsharp.dev/donate ‚ù§Ô∏è
 */
#pragma section end
// clang-format off

#define EVAL(x) x

#define HST(x) #x

#define CONCAT_2(a, b) CONCAT_IMPL(a, b)
#define CONCAT_3(a, b, c) CONCAT_IMPL(a, CONCAT_IMPL(b, c))
#define CONCAT_4(a, b, c, d) CONCAT_IMPL(CONCAT_IMPL(a, b), CONCAT_IMPL(c, d))

#define CONCAT_IMPL(a, b) a##b

#define __STAR__ *
// clang-format off

/**
 * # Register usage
 *
 * Z0 - Z4  : Mnemonic control
 * Z5       : Scope
 * Z6       : Selector control
 * Z7       : Parameters
 * Z8       : Control flow
 * Z9       : Stack control
 * Z10 - Z13: Unallocated
 * Z14      : Debugger control
 * Z15      : PC
 */

/* Architecture mapping */

/* x86_64 (64-bit) */
#if defined(__x86_64__) || defined(__amd64__)
	// Registers
	#define RAX rax
	#define RBX rbx
	#define RCX rcx
	#define RDX rdx
	#define RSI rsi
	#define RDI rdi
	#define RSP rsp
	#define RBP rbp
	#define R8  r8
	#define R9  r9
	#define R10 r10
	#define R11 r11
	#define R12 r12
	#define R13 r13
	#define R14 r14
	#define R15 r15
	#define RIP rip

	// Mnemonics
	#define SYSCALL syscall
	#define MOV(x, y) mov x, y
	#define LDR(x, y, z) mov x, [y + z]
	#define LDL(x, y) mov x, y
	#define LEA(x, y, z) lea x, [y + z]
	#define XOR(x, y) xor x, y
	#define ADD(x, y) add x, y
	#define SUB(x, y) sub x, y
	#define IMUL(x, y) imul x, y
	#define IDIV(x) idiv x
	#define INC(x) inc x
	#define DEC(x) dec x
	#define CMP(x, y) cmp x, y
	#define TEST(x, y) test x, y
	#define JMP(x) jmp x
	#define JE(x) je x
	#define JNE(x) jne x
	#define JG(x) jg x
	#define JL(x) jl x
	#define JGE(x) jge x
	#define JLE(x) jle x
	#define CALL(x) call x
	#define RET ret
	#define PUSH(x) push x
	#define POP(x) pop x
	#define NOP nop
	#define INT(x) int x

	// Value
	#define REF(x) $x

/* ARM64 (AArch64) */
#elif defined(__aarch64__)
	// Registers
	#define RAX x0
	#define RBX x1
	#define RCX x2
	#define RDX x3
	#define RSI x4
	#define RDI x5
	#define RSP sp
	#define RBP bp
	#define R8  x8
	#define R9  x9
	#define R10 x10
	#define R11 x11
	#define R12 x12
	#define R13 x13
	#define R14 x14
	#define R15 x15
	#define RIP pc

	// Mnemonics
	#define SYSCALL svc 0
	#define MOV(x, y) mov x, y
	#define LDR(x, y, z) ldr x, [y, z]
	#define LDL(x, y) ldr x, =y
	#define LEA(x, y, z) adr x, y
	#define XOR(x, y) eor x, x, y
	#define ADD(x, y) add x, x, y
	#define SUB(x, y) sub x, x, y
	#define IMUL(x, y) mul x, x, y
	#define IDIV(x, y) sdiv x, x, y
	#define INC(x) add x, x, REF(1)
	#define DEC(x) sub x, x, REF(1)
	#define CMP(x, y) cmp x, y
	#define TEST(x, y) ands xzr, x, y
	#define JMP(x) b x
	#define JE(x) b.eq x
	#define JNE(x) b.ne x
	#define JG(x) b.gt x
	#define JL(x) b.lt x
	#define JGE(x) b.ge x
	#define JLE(x) b.le x
	#define CALL(x) bl x
	#define RET ret
	#define PUSH(x) str x, [sp, REF(-16)]!
	#define POP(x) ldr x, [sp], REF(16)
	#define NOP nop
	#define INT(x) svc x

	// Value
	#define REF(x) HST(EVAL(x))

#else
	#error "Unsupported architecture for register mapping"
#endif

/* Z# Virtual registers */
#define Z0  RAX
#define Z1  RBX
#define Z2  RCX
#define Z3  RDX
#define Z4  RSI
#define Z5  RDI
#define Z6  RBP
#define Z7  R8
#define Z8  R9
#define Z9  R10
#define Z10 R11
#define Z11 R12
#define Z12 R13
#define Z13 R14
#define Z14 R15
#define Z15 RIP

/* System call registers */
#define Z_RC  RAX
#define Z_R1 RDI
#define Z_R2 RSI
#define Z_R3 RDX
#define Z_R4 R10
#define Z_R5 R8
#define Z_R6 R9

#define Z_R(x) EVAL(HST(x))

#define WINDOWS_SYSCALL_EXIT 0x0
#define WINDOWS_SYSCALL_WRITE 0x0
#define WINDOWS_SYSCALL_READ 0x0
#define WINDOWS_SYSCALL_OPEN 0x0
#define WINDOWS_SYSCALL_CLOSE 0x0
#define WINDOWS_SYSCALL_FORK 0x0
#define WINDOWS_SYSCALL_EXECVE 0x0
#define WINDOWS_SYSCALL_WAIT4 0x0
#define WINDOWS_SYSCALL_GETPID 0x0
#define WINDOWS_SYSCALL_GETUID 0x0
#define WINDOWS_SYSCALL_GETGID 0x0
#define WINDOWS_SYSCALL_BRK 0x0
#define WINDOWS_SYSCALL_MMAP 0x0
#define WINDOWS_SYSCALL_MUNMAP 0x0
#define WINDOWS_SYSCALL_CLONE 0x0

#define APPLE_SYSCALL_EXIT 0x2000001
#define APPLE_SYSCALL_WRITE 0x2000004
#define APPLE_SYSCALL_READ 0x2000003
#define APPLE_SYSCALL_OPEN 0x2000005
#define APPLE_SYSCALL_CLOSE 0x2000006
#define APPLE_SYSCALL_FORK 0x2000002
#define APPLE_SYSCALL_EXECVE 0x200003b
#define APPLE_SYSCALL_WAIT4 0x2000007
#define APPLE_SYSCALL_GETPID 0x2000014
#define APPLE_SYSCALL_GETUID 0x2000018
#define APPLE_SYSCALL_GETGID 0x200001a
#define APPLE_SYSCALL_BRK 0x2000034
#define APPLE_SYSCALL_MMAP 0x20000c5
#define APPLE_SYSCALL_MUNMAP 0x2000049
#define APPLE_SYSCALL_CLONE 0x20000fa

#define LINUX_SYSCALL_EXIT     0x3C
#define LINUX_SYSCALL_WRITE    0x01
#define LINUX_SYSCALL_READ     0x00
#define LINUX_SYSCALL_OPEN     0x02
#define LINUX_SYSCALL_CLOSE    0x03
#define LINUX_SYSCALL_FORK     0x39
#define LINUX_SYSCALL_EXECVE   0x3B
#define LINUX_SYSCALL_WAIT4    0x3D
#define LINUX_SYSCALL_GETPID   0x27
#define LINUX_SYSCALL_GETUID   0x66
#define LINUX_SYSCALL_GETGID   0x68
#define LINUX_SYSCALL_BRK      0x0C
#define LINUX_SYSCALL_MMAP     0x09
#define LINUX_SYSCALL_MUNMAP   0x0B
#define LINUX_SYSCALL_CLONE    0x38

// ...
// clang-format off

#if defined __WIN32
	#define TARGET "WINDOWS"
	#define SYS WINDOWS
	#define SYS_CASE_WINDOWS(...) __VA_ARGS__
#elif defined TARGET_OS_MAC
	#define TARGET "APPLE"
	#define SYS APPLE
#elif defined TARGET_OS_IPHONE
	#define TARGET "APPLE"
	#define SYS APPLE
#elif defined __linux__
	#define TARGET "LINUX"
	#define SYS LINUX
#elif defined __unix__
	#define TARGET "UNIX"
	#define SYS UNIX
#else
	#define TARGET "UNKNOWN"
	#define SYS "UNKNOWN"
#endif

#define SYSCALL_GET(x) CONCAT_2(EVAL(SYS), _SYSCALL_##x)

#define SYS_SWITCH(...) __VA_ARGS__
#define SYS_CASE(system, ...) \
	\
 _$ if system == SYS \
\
		SYS_SWITCH(__VA_ARGS__) \
\
	\
 _$ endif \


# Allocate N bytes ‚Üí result in %rax
.macro MALLOC size
	SAVE_ZASM
	MOV (RAX, REF(SYS_GET(SYSCALL_MMAP))) ;// syscall number: mmap (Linux AArch64)
	MOV (RDI, REF(0))                     ;// addr = NULL
	MOV (RSI, REF(\size))                 ;// length = size
	MOV (RDX, REF(3))                     ;// PROT_READ | PROT_WRITE
	MOV (R10, REF(0x22))                  ;// MAP_ANONYMOUS | MAP_PRIVATE
	MOV (R8, REF(-1))                     ;// fd = -1
	MOV (REF(0), R9)                      ;// offset = 0
	SYSCALL
	LOAD_ZASM
.endm

# Read value at pointer ‚Üí %reg
#   ptr = register with pointer
#   reg = output register
.macro PTR_READ ptr, reg
    MOV ([\ptr], \reg)
.endm

# Write value to pointer
#   value = register with value
#   ptr = pointer register
.macro PTR_WRITE value, ptr
    MOV (\value, [\ptr])
.endm

# Store value in memory, and return a pointer to it
#   value = register with value
#   out = output register with pointer
.macro PTR_CREATE value, size, out
    SAVE_R0_R4
    MALLOC \size               ;// allocate bytes
    MOV (\value, [RAX])        ;// store value at allocated address
    MOV (RAX, \out)            ;// return pointer
    LOAD_R0_R4
.endm

.macro LEN ptr, out
	SAVE_R0_R4
	MOV (\ptr, RCX)
1:
	MOV ([RCX], RDX)
	CMP (RDX, REF(0))
	JE (2f)
	INC (RCX)
	JMP (1b)
2:
	MOV (RCX, \out)
	LOAD_R0_R4
.endm

.macro FREE ptr, size
	SAVE
	MOV (REF(11), RAX)          ;// sys_munmap
	MOV (\ptr, RDI)             ;// pointer
	MOV (REF(\size), RSI)       ;// size in bytes
	SYSCALL
	LOAD
.endm

.macro DEBUG value
	MOV (RCX, REF(\value))
	LEN \value
	SUB (RDX, RCX)
.endm

	.arch armv8-a
	.file	"pre_memory.hpp"
	.text
	.align	2
	.global	_ZN6System9call_implEiz
	.type	_ZN6System9call_implEiz, %function
_ZN6System9call_implEiz:
.LFB4:
	.cfi_startproc
	sub	sp, sp, #304
	.cfi_def_cfa_offset 304
	str	w0, [sp, 12]
	str	x1, [sp, 248]
	str	x2, [sp, 256]
	str	x3, [sp, 264]
	str	x4, [sp, 272]
	str	x5, [sp, 280]
	str	x6, [sp, 288]
	str	x7, [sp, 296]
	str	q0, [sp, 112]
	str	q1, [sp, 128]
	str	q2, [sp, 144]
	str	q3, [sp, 160]
	str	q4, [sp, 176]
	str	q5, [sp, 192]
	str	q6, [sp, 208]
	str	q7, [sp, 224]
	adrp	x0, :got:__stack_chk_guard;ldr	x0, [x0, :got_lo12:__stack_chk_guard]
	ldr	x1, [x0]
	str	x1, [sp, 104]
	mov	x1, 0
	add	x0, sp, 304
	str	x0, [sp, 72]
	add	x0, sp, 304
	str	x0, [sp, 80]
	add	x0, sp, 240
	str	x0, [sp, 88]
	mov	w0, -56
	str	w0, [sp, 96]
	mov	w0, -128
	str	w0, [sp, 100]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L2
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L3
.L2:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L4
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L3
.L4:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L3:
	ldr	x0, [x0]
	str	x0, [sp, 16]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L6
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L7
.L6:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L8
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L7
.L8:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L7:
	ldr	x0, [x0]
	str	x0, [sp, 24]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L10
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L11
.L10:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L12
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L11
.L12:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L11:
	ldr	x0, [x0]
	str	x0, [sp, 32]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L14
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L15
.L14:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L16
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L15
.L16:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L15:
	ldr	x0, [x0]
	str	x0, [sp, 40]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L18
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L19
.L18:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L20
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L19
.L20:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L19:
	ldr	x0, [x0]
	str	x0, [sp, 48]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L22
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L23
.L22:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L24
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L23
.L24:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L23:
	ldr	x0, [x0]
	str	x0, [sp, 56]
	ldrsw	x1, [sp, 12]
	ldr	x2, [sp, 16]
	ldr	x6, [sp, 24]
	ldr	x7, [sp, 32]
	ldr	x11, [sp, 40]
	ldr	x12, [sp, 48]
	ldr	x13, [sp, 56]
#APP
// 83 "dist/compiled/pre_memory.hpp" 1
	mov x1, %rax
mov x2, %rdi
mov x6, %rsi
mov x7, %rdx
mov x11, %r10
mov x12, %r8
mov x13, %r9
syscall
mov %rax, x1

// 0 "" 2
#NO_APP
	str	x1, [sp, 64]
	brk #1000
	.cfi_endproc
.LFE4:
	.size	_ZN6System9call_implEiz, .-_ZN6System9call_implEiz
	.align	2
	.global	_ZN6Memory8allocateEv
	.type	_ZN6Memory8allocateEv, %function
_ZN6Memory8allocateEv:
.LFB5:
	.cfi_startproc
#APP
// 105 "dist/compiled/pre_memory.hpp" 1
	mov rdi, r8
call allocate_impl
mov rbp, rax
ret

// 0 "" 2
#NO_APP
	brk #1000
	.cfi_endproc
.LFE5:
	.size	_ZN6Memory8allocateEv, .-_ZN6Memory8allocateEv
	.align	2
	.global	_ZN6Memory13allocate_implEi
	.type	_ZN6Memory13allocate_implEi, %function
_ZN6Memory13allocate_implEi:
.LFB6:
	.cfi_startproc
	stp	x29, x30, [sp, -32]!
	.cfi_def_cfa_offset 32
	.cfi_offset 29, -32
	.cfi_offset 30, -24
	mov	x29, sp
	str	w0, [sp, 28]
	ldr	w1, [sp, 28]
	mov	w0, 9
	bl	_ZN6System9call_implEiz
	brk #1000
	.cfi_endproc
.LFE6:
	.size	_ZN6Memory13allocate_implEi, .-_ZN6Memory13allocate_implEi
	.ident	"GCC: (Ubuntu 14.3.0-1ubuntu1) 14.3.0"
	.section	.note.GNU-stack,"",@progbits

# Usage: 
# STRUCT name
#   STRUCT_FIELD field_name, size
# STRUCT_END

.set STRUCT_OFFSET, 0

.macro STRUCT name
	.set \name\()_SIZE, 0
	.pushsection .data
\name:
.endm

.macro STRUCT_FIELD name, size
\name:
	.skip \size
	.set STRUCT_OFFSET, STRUCT_OFFSET + \size
.endm

.macro STRUCT_END
	.popsection
	.set STRUCT_SIZE, STRUCT_OFFSET
	.set STRUCT_OFFSET, 0
.endm

.macro ALIGN boundary
	.balign \boundary
.endm

.macro VAR id, value, out
	;// TODO
.endm

.macro FUNC name, _
	.section .text
	.global \name
\name:
.endm

.macro PARAM type, name
	# Store param info
	.quad 0x10
	.asciz "\name"
	.quad \type
.endm

.macro PARAMS_END
	.quad 0x11
.endm

.macro FUNC_END
	.quad 0xFF
.endm

.macro RETURN value
	MOV (Z6, \value)
.endm

	.arch armv8-a
	.file	"pre_memory.hpp"
	.text
	.align	2
	.global	_ZN6System9call_implEiz
	.type	_ZN6System9call_implEiz, %function
_ZN6System9call_implEiz:
.LFB4:
	.cfi_startproc
	sub	sp, sp, #304
	.cfi_def_cfa_offset 304
	str	w0, [sp, 12]
	str	x1, [sp, 248]
	str	x2, [sp, 256]
	str	x3, [sp, 264]
	str	x4, [sp, 272]
	str	x5, [sp, 280]
	str	x6, [sp, 288]
	str	x7, [sp, 296]
	str	q0, [sp, 112]
	str	q1, [sp, 128]
	str	q2, [sp, 144]
	str	q3, [sp, 160]
	str	q4, [sp, 176]
	str	q5, [sp, 192]
	str	q6, [sp, 208]
	str	q7, [sp, 224]
	adrp	x0, :got:__stack_chk_guard;ldr	x0, [x0, :got_lo12:__stack_chk_guard]
	ldr	x1, [x0]
	str	x1, [sp, 104]
	mov	x1, 0
	add	x0, sp, 304
	str	x0, [sp, 72]
	add	x0, sp, 304
	str	x0, [sp, 80]
	add	x0, sp, 240
	str	x0, [sp, 88]
	mov	w0, -56
	str	w0, [sp, 96]
	mov	w0, -128
	str	w0, [sp, 100]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L2
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L3
.L2:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L4
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L3
.L4:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L3:
	ldr	x0, [x0]
	str	x0, [sp, 16]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L6
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L7
.L6:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L8
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L7
.L8:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L7:
	ldr	x0, [x0]
	str	x0, [sp, 24]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L10
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L11
.L10:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L12
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L11
.L12:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L11:
	ldr	x0, [x0]
	str	x0, [sp, 32]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L14
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L15
.L14:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L16
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L15
.L16:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L15:
	ldr	x0, [x0]
	str	x0, [sp, 40]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L18
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L19
.L18:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L20
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L19
.L20:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L19:
	ldr	x0, [x0]
	str	x0, [sp, 48]
	ldr	w1, [sp, 96]
	ldr	x0, [sp, 72]
	cmp	w1, 0
	blt	.L22
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L23
.L22:
	add	w2, w1, 8
	str	w2, [sp, 96]
	ldr	w2, [sp, 96]
	cmp	w2, 0
	ble	.L24
	add	x1, x0, 15
	and	x1, x1, -8
	str	x1, [sp, 72]
	b	.L23
.L24:
	ldr	x2, [sp, 80]
	sxtw	x0, w1
	add	x0, x2, x0
.L23:
	ldr	x0, [x0]
	str	x0, [sp, 56]
	ldrsw	x1, [sp, 12]
	ldr	x2, [sp, 16]
	ldr	x6, [sp, 24]
	ldr	x7, [sp, 32]
	ldr	x11, [sp, 40]
	ldr	x12, [sp, 48]
	ldr	x13, [sp, 56]
#APP
// 83 "dist/compiled/pre_memory.hpp" 1
	mov x1, %rax
mov x2, %rdi
mov x6, %rsi
mov x7, %rdx
mov x11, %r10
mov x12, %r8
mov x13, %r9
syscall
mov %rax, x1

// 0 "" 2
#NO_APP
	str	x1, [sp, 64]
	brk #1000
	.cfi_endproc
.LFE4:
	.size	_ZN6System9call_implEiz, .-_ZN6System9call_implEiz
	.align	2
	.global	_ZN6Memory8allocateEv
	.type	_ZN6Memory8allocateEv, %function
_ZN6Memory8allocateEv:
.LFB5:
	.cfi_startproc
#APP
// 105 "dist/compiled/pre_memory.hpp" 1
	mov rdi, r8
call allocate_impl
mov rbp, rax
ret

// 0 "" 2
#NO_APP
	brk #1000
	.cfi_endproc
.LFE5:
	.size	_ZN6Memory8allocateEv, .-_ZN6Memory8allocateEv
	.align	2
	.global	_ZN6Memory13allocate_implEi
	.type	_ZN6Memory13allocate_implEi, %function
_ZN6Memory13allocate_implEi:
.LFB6:
	.cfi_startproc
	stp	x29, x30, [sp, -32]!
	.cfi_def_cfa_offset 32
	.cfi_offset 29, -32
	.cfi_offset 30, -24
	mov	x29, sp
	str	w0, [sp, 28]
	ldr	w1, [sp, 28]
	mov	w0, 9
	bl	_ZN6System9call_implEiz
	brk #1000
	.cfi_endproc
.LFE6:
	.size	_ZN6Memory13allocate_implEi, .-_ZN6Memory13allocate_implEi
	.ident	"GCC: (Ubuntu 14.3.0-1ubuntu1) 14.3.0"
	.section	.note.GNU-stack,"",@progbits

# Type initialization
.macro TYPE name
	STRUCT \name
.endm

.macro TYPE_FIELD type, name
	#if type == BYTE
		STRUCT_FIELD \name
	#endif
.endm

.macro TYPE_END
	STRUCT_END
.endm

.macro SCOPE name
	
.endm

.macro SCOPE_SET name, value
	
.endm

.section .text
.global _start
_start:
	

// clang-format off
