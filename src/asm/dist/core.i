
/*
 * This code was generated by the Z# programming system. 🫎
 *
 * Z# is an open-source community project. By using Z#, you acknowledge and agree:
 *
 * - You trust the code you are running.
 * - You may not hold the Z# organization, its developers, or contributors liable
 *   for any damage caused by the code, even if it behaves maliciously. 
 * - Responsibility for malicious or harmful behavior lies solely with the author
 *   of the code, not with Z# or its maintainers. 👺
 *
 * Z# is not designed to generate malicious code, but like any programming tool,
 * it can be used to write harmful or unsafe programs.
 *
 * If you find Z# useful, please consider supporting the project:
 * https://zsharp.dev/donate. ❤️
 *
 * Use at your own risk. ⚠️
 */

#define EVAL(x) x

/*
 * R0 - R4 : Mnemonic control
 * R5      : Scope
 * R6      : Selector control
 * R7      : Parameter control
 * R8      : Stack
 * R9 - R14: Unallocated
 * R15     : Temporary
 */
# Architecture mapping

/* x86_64 (64-bit) */
#if defined(__x86_64__) || defined(__amd64__)
    # Registers
    #define RAX rax
    #define RBX rbx
    #define RCX rcx
    #define RDX rdx
    #define RSI rsi
    #define RDI rdi
    #define RSP rsp
    #define RBP rbp
    #define R8  r8
    #define R9  r9
    #define R10 r10
    #define R11 r11
    #define R12 r12
    #define R13 r13
    #define R14 r14
    #define R15 r15

    #define RIP rip

    # Mnemonics
    #define SYSCALL syscall
    #define MOV(x, y) mov x, y
    #define LDR(x, y) mov (x), y
    #define LEA(x, y, z) lea x(z), y
	#define XOR(x, y) xor x, y
	#define ADD(x, y) add x, y
	#define SUB(x, y) sub x, y
	#define IMUL(x, y) imul x, y

	#define JNE(x, y) jne x, y
	
    # Value
    #define REF(x) $x
/* ARM64 (AArch64) */
#elif defined(__aarch64__)
    # Registers
    #define RAX x0
    #define RBX x1
    #define RCX x2
    #define RDX x3
    #define RSI x4
    #define RDI x5
    #define RSP sp
    #define RBP x29
    #define R8  x8
    #define R9  x9
    #define R10 x10
    #define R11 x11
    #define R12 x12
    #define R13 x13
    #define R14 x14
    #define R15 x15

    #define RIP rip

    # Mnemonics
    #define SYSCALL svc 0
	#define MOV(x, y) mov y, x
	#define LDR(x, y) ldr y, [x]
	#define LEA(x, y, z) adr y, x
	#define XOR(x, y) eor x, x, y
	#define ADD(x, y) add x, x, y
	#define SUB(x, y) sub x, x, y
	#define IMUL(x, y, z) MOV(x, R15) __NL__ \
						  MUL R15, y, z

	#define JNE(x, y) 
	
    # Value
    #define REF(x) #EVAL(x)
#else
    #error "Unsupported architecture for register mapping"
#endif

#ifdef __WIN32
	#define TARGET "MICROSOFT/WINDOWS"
#elif TARGET_OS_MAC
	#define TARGET "APPLE/MAC-OS"
#elif TARGET_OS_IPHONE
	#define TARGET "APPLE/IPHONE"
#elif __linux__
	#define TARGET "LINUX"
#elif __ANDROID__
	#define TARGET "ANDROID"
#elif __unix__
	#define TARGET "UNIX"
#else
	#define TARGET "UNKNOWN"
#endif

# Usage: 
# STRUCT name
#   STRUCT_FIELD field_name, size
# STRUCT_END

.set STRUCT_OFFSET, 0

.macro STRUCT name
    .set \name\()_SIZE, 0
    .pushsection .data
\name:
.endm

.macro STRUCT_FIELD name, size
\name:
    .skip \size
    .set STRUCT_OFFSET, STRUCT_OFFSET + \size
.endm

.macro STRUCT_END
    .popsection
    .set STRUCT_SIZE, STRUCT_OFFSET
    .set STRUCT_OFFSET, 0
.endm

.macro ALIGN boundary
    .balign \boundary
.endm

# Allocate N bytes → result in %rax
.macro MALLOC size
    MOV (REF(9), RAX)     ;// sys_mmap
    XOR (RDI, RDI)        ;// NULL address
    MOV (REF(\size), RSI) ;// size in bytes
    MOV (REF(3), RAX)     ;// PROT_READ | PROT_WRITE
    MOV (REF(34), R10)    ;// MAP_PRIVATE | MAP_ANONYMOUS
    XOR (R8, R8)          ;// fd = -1
    XOR (R9, R9)          ;// offset
    SYSCALL               ;// -> %rax = allocated pointer
.endm

# Read value at pointer → %reg
#   ptr = register with pointer
#   reg = output register
.macro PTR_READ ptr, reg
    MOV ((\ptr), \reg)
.endm

# Write value to pointer
#   value = register with value
#   ptr = pointer register
.macro PTR_WRITE value, ptr
    MOV (\value, (\ptr))
.endm

# Store value in memory, and return a pointer to it
#   value = register with value
#   out = output register with pointer
.macro PTR_CREATE value, out
    MALLOC 8            ;// allocate 8 bytes
    MOV (\value, (RAX)) ;// store value at allocated address
    MOV (RAX, \out)     ;// return pointer
.endm

# Optional, depending on the environment
.macro FREE ptr, size
    MOV (REF(11), RAX)    ;// sys_munmap
   	MOV (REF(\ptr), RDI)  ;// pointer
    MOV (REF(\size), RSI) ;// size in bytes
    SYSCALL
.endm

# Allocate the table itself once
.macro LAZY_LIST_INIT name, slots
    .lcomm \name, \slots * 8
.endm

# Get address of list[index] → in %rdi
.macro LAZY_PTR_GET name, index, reg
    LEA (\name, \reg, RIP)
    MOV (REF(\index), RSI)
    IMUL (REF(8), RSI, RSI)
    ADD (RSI, \reg)
.endm

# Access item at index, allocate if null
#   name = list name
#   index = integer index
#   size = allocation size
#   reg = register for result address
.macro LAZY_BLOCK_GET name, index, size, reg
    LAZY_PTR_GET \name, \index, \reg
    MOV ((\reg), RSI)
    JNE (REF(1f), RSI)
    MALLOC \size
    MOV (RAX, \reg)
1:
    LDR (\reg, \reg)
.endm

# Set value at a specific index in a lazy list
#   name = list name
#   index = integer index
#   value = value to set (in register)
.macro LAZY_BLOCK_SET name, index, value
    LAZY_PTR_GET \name, \index, RDI
    MOV (REF(\value), RDI)
.endm

# Type initialization
.macro TYPE name
    STRUCT \name
.endm

.macro TYPE_FIELD type, name, size
    #if type == BYTE
        STRUCT_FIELD \name, \size
    #endif
.endm

.macro TYPE_END
    STRUCT_END
.endm

.macro FUNC name, _
.section .text
.global \name
\name:
.endm

.macro PARAM type, name
# Store param info
.byte 0x10
.asciz "\name"
.byte \type
.endm

.macro PARAMS_END
.byte 0x11
.endm

.macro FUNC_END
.byte 0xFF
.endm

.macro DEBUG value
    MOV(REF(1), RAX)  ;// sys_write system call
    MOV(REF(1), RDI)  ;// stdout file descriptor
    MOV(\value, RSI)  ;// pointer to the string
    MOV(REF(10), RDX) ;// length of the string
    SYSCALL
.endm

.macro STRING name, string
	.section data
		\name: .asciz \string
	.section text
.endm

