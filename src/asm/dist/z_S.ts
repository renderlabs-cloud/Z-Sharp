export default "\n/*\n * This code was generated by the Z# programming system. ü´é ‚ù§Ô∏è\n *\n * Z# is an open-source project licensed under the MIT License\n * with the following restriction:\n *\n * - You may use, copy, modify, merge, publish, distribute, and sublicense\n *   this software freely, **but you may NOT sell the original software\n *   or derivative works as standalone products.**\n *\n * - This software is provided \"AS IS\", without warranty of any kind.\n *\n * - The Z# organization, its developers, and contributors disclaim all liability\n *   for any damages arising from the use of this software.\n *\n * - Responsibility for malicious or harmful code lies solely with the author,\n *   not with Z# or its maintainers.\n *\n * Z# is not intended to generate malicious code, but like any tool,\n * it can be misused. Use at your own risk.\n *\n * If you find Z# useful, please consider supporting the project:\n * https://zsharp.dev/donate ‚ù§Ô∏è\n */\n\n#define EVAL(x) x\n\n#define CONCAT_2(a, b) CONCAT_IMPL(a, b)\n#define CONCAT_3(a, b, c) CONCAT_IMPL(a, CONCAT_IMPL(b, c))\n#define CONCAT_4(a, b, c, d) CONCAT_IMPL(CONCAT_IMPL(a, b), CONCAT_IMPL(c, d))\n\n#define CONCAT_IMPL(a, b) a##b\n\n/**\n * # Register usage\n *\n * R0 - R4  : Mnemonic control\n * R5       : Scope\n * R6       : Selector control\n * R7       : Parameters\n * R8       : Call control\n * R9       : Stack control\n * R10 - R13: Unallocated\n * R14      : Debugger control\n * R15      : Temporary\n */\n\n# Architecture mapping\n\n/* x86_64 (64-bit) */\n#if defined(__x86_64__) || defined(__amd64__)\n\t# Registers\n\t#define RAX rax\n\t#define RBX rbx\n\t#define RCX rcx\n\t#define RDX rdx\n\t#define RSI rsi\n\t#define RDI rdi\n\t#define RSP rsp\n\t#define RBP rbp\n\t#define R8  r8\n\t#define R9  r9\n\t#define R10 r10\n\t#define R11 r11\n\t#define R12 r12\n\t#define R13 r13\n\t#define R14 r14\n\t#define R15 r15\n\t#define RIP rip\n\n\t# Mnemonics\n\t#define SYSCALL syscall\n\t#define MOV(x, y) mov x, y\n\t#define LDR(x, y, z) mov x, [y + z]\n\t#define LDL(x, y) mov x, y\n\t#define LEA(x, y, z) lea x, [y + z]\n\t#define XOR(x, y) xor x, y\n\t#define ADD(x, y) add x, y\n\t#define SUB(x, y) sub x, y\n\t#define IMUL(x, y) imul x, y\n\t#define IDIV(x) idiv x\n\t#define INC(x) inc x\n\t#define DEC(x) dec x\n\t#define CMP(x, y) cmp x, y\n\t#define TEST(x, y) test x, y\n\t#define JMP(x) jmp x\n\t#define JE(x) je x\n\t#define JNE(x) jne x\n\t#define JG(x) jg x\n\t#define JL(x) jl x\n\t#define JGE(x) jge x\n\t#define JLE(x) jle x\n\t#define CALL(x) call x\n\t#define RET ret\n\t#define PUSH(x) push x\n\t#define POP(x) pop x\n\t#define NOP nop\n\t#define INT(x) int x\n\n\t# Value\n\t#define REF(x) $x\n\n/* ARM64 (AArch64) */\n#elif defined(__aarch64__)\n\t# Registers\n\t#define RAX x0\n\t#define RBX x1\n\t#define RCX x2\n\t#define RDX x3\n\t#define RSI x4\n\t#define RDI x5\n\t#define RSP sp\n\t#define RBP x29\n\t#define R8  x8\n\t#define R9  x9\n\t#define R10 x10\n\t#define R11 x11\n\t#define R12 x12\n\t#define R13 x13\n\t#define R14 x14\n\t#define R15 x15\n\t#define RIP pc\n\n\t# Mnemonics\n\t#define SYSCALL svc 0\n\t#define MOV(x, y) mov x, y\n\t#define LDR(x, y, z) ldr x, [y, z]\n\t#define LDL(x, y) ldr x, =y\n\t#define LEA(x, y, z) adr x, y\n\t#define XOR(x, y) eor x, x, y\n\t#define ADD(x, y) add x, x, y\n\t#define SUB(x, y) sub x, x, y\n\t#define IMUL(x, y) mul x, x, y\n\t#define IDIV(x, y) sdiv x, x, y\n\t#define INC(x) add x, x, #1\n\t#define DEC(x) sub x, x, #1\n\t#define CMP(x, y) cmp x, y\n\t#define TEST(x, y) ands xzr, x, y\n\t#define JMP(x) b x\n\t#define JE(x) b.eq x\n\t#define JNE(x) b.ne x\n\t#define JG(x) b.gt x\n\t#define JL(x) b.lt x\n\t#define JGE(x) b.ge x\n\t#define JLE(x) b.le x\n\t#define CALL(x) bl x\n\t#define RET ret\n\t#define PUSH(x) str x, [sp, #-16]!\n\t#define POP(x) ldr x, [sp], #16\n\t#define NOP nop\n\t#define INT(x) svc x\n\n\t# Value\n\t#define REF(x) #EVAL(x)\n\n#else\n\t#error \"Unsupported architecture for register mapping\"\n#endif\n\n.macro SAVE_R0_R4\n\tPUSH (RAX)\n\tPUSH (RBX)\n\tPUSH (RCX)\n\tPUSH (RDX)\n\tPUSH (RSI)\n.endm\n\n.macro LOAD_R0_R4\n\tPOP (RSI)\n\tPOP (RDX)\n\tPOP (RCX)\n\tPOP (RBX)\n\tPOP (RAX)\n.endm\n\n.macro SAVE_ZASM\n\tPUSH (RDI)\n\tPUSH (RSP)\n\tPUSH (RBP)\n\tPUSH (R8)\n\tPUSH (R9)\n\tPUSH (R10)\n\tPUSH (R11)\n\tPUSH (R12)\n\tPUSH (R13)\n\tPUSH (R14)\n\tPUSH (R15)\n.endm\n\n.macro LOAD_ZASM\n\tPOP (R15)\n\tPOP (R14)\n\tPOP (R13)\n\tPOP (R12)\n\tPOP (R11)\n\tPOP (R10)\n\tPOP (R9)\n\tPOP (R8)\n\tPOP (RBP)\n\tPOP (RSP)\n\tPOP (RDI)\n.endm\n\n.macro SAVE \n\tSAVE_R0_R4\n\tSAVE_ZASM\n.endm\n\n.macro LOAD\n\tLOAD_ZASM\n\tLOAD_R0_R4\n.endm\n\n#define WINDOWS_SYSCALL_EXIT 0\n#define WINDOWS_SYSCALL_WRITE 0\n#define WINDOWS_SYSCALL_READ 0\n#define WINDOWS_SYSCALL_OPEN 0\n#define WINDOWS_SYSCALL_CLOSE 0\n#define WINDOWS_SYSCALL_FORK 0\n#define WINDOWS_SYSCALL_EXECVE 0\n#define WINDOWS_SYSCALL_WAIT4 0\n#define WINDOWS_SYSCALL_GETPID 0\n#define WINDOWS_SYSCALL_GETUID 0\n#define WINDOWS_SYSCALL_GETGID 0\n#define WINDOWS_SYSCALL_BRK 0\n#define WINDOWS_SYSCALL_MMAP 0\n#define WINDOWS_SYSCALL_MUNMAP 0\n#define WINDOWS_SYSCALL_CLONE 0\n\n#define APPLE_SYSCALL_EXIT 0x2000001\n#define APPLE_SYSCALL_WRITE 0x2000004\n#define APPLE_SYSCALL_READ 0x2000003\n#define APPLE_SYSCALL_OPEN 0x2000005\n#define APPLE_SYSCALL_CLOSE 0x2000006\n#define APPLE_SYSCALL_FORK 0x2000002\n#define APPLE_SYSCALL_EXECVE 0x200003b\n#define APPLE_SYSCALL_WAIT4 0x2000007\n#define APPLE_SYSCALL_GETPID 0x2000014\n#define APPLE_SYSCALL_GETUID 0x2000018\n#define APPLE_SYSCALL_GETGID 0x200001a\n#define APPLE_SYSCALL_BRK 0x2000034\n#define APPLE_SYSCALL_MMAP 0x20000c5\n#define APPLE_SYSCALL_MUNMAP 0x2000049\n#define APPLE_SYSCALL_CLONE 0x20000fa\n\n#define UNIX_SYSCALL_EXIT 1\n#define UNIX_SYSCALL_WRITE 4\n#define UNIX_SYSCALL_READ 3\n#define UNIX_SYSCALL_OPEN 5\n#define UNIX_SYSCALL_CLOSE 6\n#define UNIX_SYSCALL_FORK 2\n#define UNIX_SYSCALL_EXECVE 11\n#define UNIX_SYSCALL_WAIT4 7\n#define UNIX_SYSCALL_GETPID 20\n#define UNIX_SYSCALL_GETUID 24\n#define UNIX_SYSCALL_GETGID 47\n#define UNIX_SYSCALL_BRK 17\n#define UNIX_SYSCALL_MMAP 90\n#define UNIX_SYSCALL_MUNMAP 91\n#define UNIX_SYSCALL_CLONE 120\n\n#define LINUX_SYSCALL_EXIT 60\n#define LINUX_SYSCALL_WRITE 1\n#define LINUX_SYSCALL_READ 0\n#define LINUX_SYSCALL_OPEN 2\n#define LINUX_SYSCALL_CLOSE 3\n#define LINUX_SYSCALL_FORK 57\n#define LINUX_SYSCALL_EXECVE 59\n#define LINUX_SYSCALL_WAIT4 61\n#define LINUX_SYSCALL_GETPID 39\n#define LINUX_SYSCALL_GETUID 102\n#define LINUX_SYSCALL_GETGID 104\n#define LINUX_SYSCALL_BRK 12\n#define LINUX_SYSCALL_MMAP 9\n#define LINUX_SYSCALL_MUNMAP 11\n#define LINUX_SYSCALL_CLONE 56\n\n#ifdef __WIN32\n\t#define TARGET \"MICROSOFT/WINDOWS\"\n\t#define SYS WINDOWS\n#elif TARGET_OS_MAC\n\t#define TARGET \"APPLE/MAC-OS\"\n\t#define SYS APPLE\n#elif TARGET_OS_IPHONE\n\t#define TARGET \"APPLE/IPHONE\"\n\t#define SYS APPLE\n#elif __linux__\n\t#define TARGET \"LINUX\"\n\t#define SYS LINUX\n#elif __ANDROID__\n\t#define TARGET \"ANDROID\"\n\t#define SYS LINUX\n#elif __unix__\n\t#define TARGET \"UNIX\"\n\t#define SYS UNIX\n#else\n\t#define TARGET \"UNKNOWN\"\n\t#define SYS LINUX\n#endif\n\n#define SYS_GET(x) CONCAT_2(EVAL(SYS), _##x)\n\n# Allocate N bytes ‚Üí result in %rax\n.macro MALLOC size\n\tSAVE_ZASM\n\tMOV (RAX, REF(SYS_GET(SYSCALL_MMAP))) ;// syscall number: mmap (Linux AArch64)\n\tMOV (RDI, REF(0))                     ;// addr = NULL\n\tMOV (RSI, REF(\\size))                 ;// length = size\n\tMOV (RDX, REF(3))                     ;// PROT_READ | PROT_WRITE\n\tMOV (R10, REF(0x22))                  ;// MAP_ANONYMOUS | MAP_PRIVATE\n\tMOV (R8, REF(-1))                     ;// fd = -1\n\tMOV (REF(0), R9)                      ;// offset = 0\n\tSYSCALL\n\tLOAD_ZASM\n.endm\n\n# Read value at pointer ‚Üí %reg\n#   ptr = register with pointer\n#   reg = output register\n.macro PTR_READ ptr, reg\n    MOV ([\\ptr], \\reg)\n.endm\n\n# Write value to pointer\n#   value = register with value\n#   ptr = pointer register\n.macro PTR_WRITE value, ptr\n    MOV (\\value, [\\ptr])\n.endm\n\n# Store value in memory, and return a pointer to it\n#   value = register with value\n#   out = output register with pointer\n.macro PTR_CREATE value, size, out\n    SAVE_R0_R4\n    MALLOC \\size               ;// allocate bytes\n    MOV (\\value, [RAX])        ;// store value at allocated address\n    MOV (RAX, \\out)            ;// return pointer\n    LOAD_R0_R4\n.endm\n\n.macro LEN ptr, out\n\tSAVE_R0_R4\n\tMOV (\\ptr, RCX)\n1:\n\tMOV ([RCX], RDX)\n\tCMP (RDX, REF(0))\n\tJE (2f)\n\tINC (RCX)\n\tJMP (1b)\n2:\n\tMOV (RCX, \\out)\n\tLOAD_R0_R4\n.endm\n\n.macro FREE ptr, size\n\tSAVE\n\tMOV (REF(11), RAX)          ;// sys_munmap\n\tMOV (\\ptr, RDI)             ;// pointer\n\tMOV (REF(\\size), RSI)       ;// size in bytes\n\tSYSCALL\n\tLOAD\n.endm\n\n.macro DEBUG value\n\tMOV (RCX, REF(\\value))\n\tLEN \\value\n\tSUB (RDX, RCX)\n.endm\n\n.section .data\ndebug_msg:\n\t.asciz \"Hello, Debug!\"\n\n.section .text\n.global _start\n_start:\n\tDEBUG debug_msg\n\n# Allocate the table itself once\n.macro LAZY_LIST_INIT name, slots\n    .lcomm \\name, \\slots * 8\n.endm\n\n# Get address of list[index] ‚Üí in %rdi\n.macro LAZY_PTR_GET name, index, reg\n\tSAVE\n\tLEA (\\name, \\reg, RIP)\n\tMOV (REF(\\index), RSI)\n\tIMUL (REF(8), RSI)\n\tADD (RSI, \\reg)\n\tLOAD\n.endm\n\n# Access item at index, allocate if null\n#   name = list name\n#   index = integer index\n#   size = allocation size\n#   reg = register for result address\n.macro LAZY_BLOCK_GET name, index, size, reg\n\tSAVE\n\tLAZY_PTR_GET \\name, \\index, \\reg\n\tMOV ((\\reg), RSI)\n\tJNE (REF(1f))\n\tMALLOC \\size\n\tMOV (RAX, \\reg)\n1:\n\tLDR (\\reg, \\reg, 0)\n\tLOAD\n.endm\n\n# Set value at a specific index in a lazy list\n#   name = list name\n#   index = integer index\n#   value = value to set (in register)\n.macro LAZY_BLOCK_SET name, index, value\n\tSAVE\n\tLAZY_PTR_GET \\name, \\index, RDI\n\tMOV (REF(\\value), RDI)\n\tLOAD\n.endm\n\n# Usage: \n# STRUCT name\n#   STRUCT_FIELD field_name, size\n# STRUCT_END\n\n.set STRUCT_OFFSET, 0\n\n.macro STRUCT name\n\t.set \\name\\()_SIZE, 0\n\t.pushsection .data\n\\name:\n.endm\n\n.macro STRUCT_FIELD name, size\n\\name:\n\t.skip \\size\n\t.set STRUCT_OFFSET, STRUCT_OFFSET + \\size\n.endm\n\n.macro STRUCT_END\n\t.popsection\n\t.set STRUCT_SIZE, STRUCT_OFFSET\n\t.set STRUCT_OFFSET, 0\n.endm\n\n.macro ALIGN boundary\n\t.balign \\boundary\n.endm\n\n.macro VAR id, value, out\n\t;// TODO\n.endm\n.macro FUNC name, _\n\t.section .text\n\t.global \\name\n\\name:\n.endm\n\n.macro PARAM type, name\n\t# Store param info\n\t.quad 0x10\n\t.asciz \"\\name\"\n\t.quad \\type\n.endm\n\n.macro PARAMS_END\n\t.quad 0x11\n.endm\n\n.macro FUNC_END\n\t.quad 0xFF\n.endm\n\n# Type initialization\n.macro TYPE name\n\tSTRUCT \\name\n.endm\n\n.macro TYPE_FIELD type, name, size\n\t#if type == BYTE\n\t\tSTRUCT_FIELD \\name, \\size\n\t#endif\n.endm\n\n.macro TYPE_END\n\tSTRUCT_END\n.endm\n\n";
