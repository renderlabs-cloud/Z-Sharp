export default "\n/*\n * This code was generated by the Z# programming system. ðŸ«Ž\n *\n * Z# is an open-source community project. By using Z#, you acknowledge and agree:\n *\n * - You trust the code you are running.\n * - You may not hold the Z# organization, its developers, or contributors liable\n *   for any damage caused by the code, even if it behaves maliciously. \n * - Responsibility for malicious or harmful behavior lies solely with the author\n *   of the code, not with Z# or its maintainers. ðŸ‘º\n *\n * Z# is not designed to generate malicious code, but like any programming tool,\n * it can be used to write harmful or unsafe programs.\n *\n * If you find Z# useful, please consider supporting the project:\n * https://zsharp.dev/donate. â¤ï¸\n *\n * Use at your own risk. âš ï¸\n */\n\n#define EVAL(x) x\n\n/*\n * R0 - R4 : Mnemonic control\n * R5      : Scope\n * R6      : Selector control\n * R7      : Parameter control\n * R8      : Stack\n * R9 - R14: Unallocated\n * R15     : Temporary\n */\n# Architecture mapping\n\n/* x86_64 (64-bit) */\n#if defined(__x86_64__) || defined(__amd64__)\n    # Registers\n    #define RAX rax\n    #define RBX rbx\n    #define RCX rcx\n    #define RDX rdx\n    #define RSI rsi\n    #define RDI rdi\n    #define RSP rsp\n    #define RBP rbp\n    #define R8  r8\n    #define R9  r9\n    #define R10 r10\n    #define R11 r11\n    #define R12 r12\n    #define R13 r13\n    #define R14 r14\n    #define R15 r15\n\n    #define RIP rip\n\n    # Mnemonics\n    #define SYSCALL syscall\n    #define MOV(x, y) mov x, y\n    #define LDR(x, y) mov (x), y\n    #define LEA(x, y, z) lea x(z), y\n\t#define XOR(x, y) xor x, y\n\t#define ADD(x, y) add x, y\n\t#define SUB(x, y) sub x, y\n\t#define IMUL(x, y) imul x, y\n\n\t#define JNE(x, y) jne x, y\n\t\n    # Value\n    #define REF(x) $x\n/* ARM64 (AArch64) */\n#elif defined(__aarch64__)\n    # Registers\n    #define RAX x0\n    #define RBX x1\n    #define RCX x2\n    #define RDX x3\n    #define RSI x4\n    #define RDI x5\n    #define RSP sp\n    #define RBP x29\n    #define R8  x8\n    #define R9  x9\n    #define R10 x10\n    #define R11 x11\n    #define R12 x12\n    #define R13 x13\n    #define R14 x14\n    #define R15 x15\n\n    #define RIP rip\n\n    # Mnemonics\n    #define SYSCALL svc 0\n\t#define MOV(x, y) mov y, x\n\t#define LDR(x, y) ldr y, [x]\n\t#define LEA(x, y, z) adr y, x\n\t#define XOR(x, y) eor x, x, y\n\t#define ADD(x, y) add x, x, y\n\t#define SUB(x, y) sub x, x, y\n\t#define IMUL(x, y, z) MOV(x, R15) \n \\\n\t\t\t\t\t\t  MUL R15, y, z\n\n\t#define JNE(x, y) \n\t\n    # Value\n    #define REF(x) #EVAL(x)\n#else\n    #error \"Unsupported architecture for register mapping\"\n#endif\n\n#ifdef __WIN32\n\t#define TARGET \"MICROSOFT/WINDOWS\"\n#elif TARGET_OS_MAC\n\t#define TARGET \"APPLE/MAC-OS\"\n#elif TARGET_OS_IPHONE\n\t#define TARGET \"APPLE/IPHONE\"\n#elif __linux__\n\t#define TARGET \"LINUX\"\n#elif __ANDROID__\n\t#define TARGET \"ANDROID\"\n#elif __unix__\n\t#define TARGET \"UNIX\"\n#else\n\t#define TARGET \"UNKNOWN\"\n#endif\n\n# Usage: \n# STRUCT name\n#   STRUCT_FIELD field_name, size\n# STRUCT_END\n\n.set STRUCT_OFFSET, 0\n\n.macro STRUCT name\n    .set \\name\\()_SIZE, 0\n    .pushsection .data\n\\name:\n.endm\n\n.macro STRUCT_FIELD name, size\n\\name:\n    .skip \\size\n    .set STRUCT_OFFSET, STRUCT_OFFSET + \\size\n.endm\n\n.macro STRUCT_END\n    .popsection\n    .set STRUCT_SIZE, STRUCT_OFFSET\n    .set STRUCT_OFFSET, 0\n.endm\n\n.macro ALIGN boundary\n    .balign \\boundary\n.endm\n\n# Allocate N bytes â†’ result in %rax\n.macro MALLOC size\n    MOV (REF(9), RAX)     ;// sys_mmap\n    XOR (RDI, RDI)        ;// NULL address\n    MOV (REF(\\size), RSI) ;// size in bytes\n    MOV (REF(3), RAX)     ;// PROT_READ | PROT_WRITE\n    MOV (REF(34), R10)    ;// MAP_PRIVATE | MAP_ANONYMOUS\n    XOR (R8, R8)          ;// fd = -1\n    XOR (R9, R9)          ;// offset\n    SYSCALL               ;// -> %rax = allocated pointer\n.endm\n\n# Read value at pointer â†’ %reg\n#   ptr = register with pointer\n#   reg = output register\n.macro PTR_READ ptr, reg\n    MOV ((\\ptr), \\reg)\n.endm\n\n# Write value to pointer\n#   value = register with value\n#   ptr = pointer register\n.macro PTR_WRITE value, ptr\n    MOV (\\value, (\\ptr))\n.endm\n\n# Store value in memory, and return a pointer to it\n#   value = register with value\n#   out = output register with pointer\n.macro PTR_CREATE value, out\n    MALLOC 8            ;// allocate 8 bytes\n    MOV (\\value, (RAX)) ;// store value at allocated address\n    MOV (RAX, \\out)     ;// return pointer\n.endm\n\n# Optional, depending on the environment\n.macro FREE ptr, size\n    MOV (REF(11), RAX)    ;// sys_munmap\n   \tMOV (REF(\\ptr), RDI)  ;// pointer\n    MOV (REF(\\size), RSI) ;// size in bytes\n    SYSCALL\n.endm\n\n# Allocate the table itself once\n.macro LAZY_LIST_INIT name, slots\n    .lcomm \\name, \\slots * 8\n.endm\n\n# Get address of list[index] â†’ in %rdi\n.macro LAZY_PTR_GET name, index, reg\n    LEA (\\name, \\reg, RIP)\n    MOV (REF(\\index), RSI)\n    IMUL (REF(8), RSI, RSI)\n    ADD (RSI, \\reg)\n.endm\n\n# Access item at index, allocate if null\n#   name = list name\n#   index = integer index\n#   size = allocation size\n#   reg = register for result address\n.macro LAZY_BLOCK_GET name, index, size, reg\n    LAZY_PTR_GET \\name, \\index, \\reg\n    MOV ((\\reg), RSI)\n    JNE (REF(1f), RSI)\n    MALLOC \\size\n    MOV (RAX, \\reg)\n1:\n    LDR (\\reg, \\reg)\n.endm\n\n# Set value at a specific index in a lazy list\n#   name = list name\n#   index = integer index\n#   value = value to set (in register)\n.macro LAZY_BLOCK_SET name, index, value\n    LAZY_PTR_GET \\name, \\index, RDI\n    MOV (REF(\\value), RDI)\n.endm\n\n# Type initialization\n.macro TYPE name\n    STRUCT \\name\n.endm\n\n.macro TYPE_FIELD type, name, size\n    #if type == BYTE\n        STRUCT_FIELD \\name, \\size\n    #endif\n.endm\n\n.macro TYPE_END\n    STRUCT_END\n.endm\n\n.macro FUNC name, _\n.section .text\n.global \\name\n\\name:\n.endm\n\n.macro PARAM type, name\n# Store param info\n.byte 0x10\n.asciz \"\\name\"\n.byte \\type\n.endm\n\n.macro PARAMS_END\n.byte 0x11\n.endm\n\n.macro FUNC_END\n.byte 0xFF\n.endm\n\n.macro DEBUG value\n    MOV(REF(1), RAX)  ;// sys_write system call\n    MOV(REF(1), RDI)  ;// stdout file descriptor\n    MOV(\\value, RSI)  ;// pointer to the string\n    MOV(REF(10), RDX) ;// length of the string\n    SYSCALL\n.endm\n\n.macro STRING name, string\n\t.section data\n\t\t\\name: .asciz \\string\n\t.section text\n.endm\n\n";
