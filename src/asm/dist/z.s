/* Copyright (C) 1991-2025 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */
/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */
/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */
/* wchar_t uses Unicode 10.0.0.  Version 10.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2017, fifth edition, plus
   the following additions from Amendment 1 to the fifth edition:
   - 56 emoji characters
   - 285 hentaigana
   - 3 additional Zanabazar Square characters */
// clang-format off
/**
 * ! READ THIS !
 *
 * # Legal statements
 *
 * This code was generated by the Z# programming system. ü´é ‚ù§Ô∏è
 *
 * Z# is an open-source project licensed under the MIT License
 * with the following restriction:
 *
 * - You may use, copy, modify, merge, publish, distribute, and sublicense
 *   this software freely, **but you may NOT sell the original software
 *   or derivative works as standalone products.**
 *
 * - This software is provided "AS IS", without warranty of any kind.
 *
 * - The Z# organization, its developers, and contributors disclaim all liability
 *   for any damages arising from the use of this software.
 *
 * - Responsibility for malicious or harmful code lies solely with the author,
 *   not with Z# or its maintainers.
 *
 * Z# is not intended to generate malicious code, but like any tool,
 * it can be misused. Use at your own risk.
 *
 * If you find Z# useful, please consider supporting the project:
 * https://zsharp.dev/donate ‚ù§Ô∏è
 */
// clang-format off
// clang-format off
/**
 * # Register usage
 *
 * Z0 - Z4  : Mnemonic control
 * Z5       : Scope
 * Z6       : Selector control
 * Z7       : Parameters
 * Z8       : Control flow
 * Z9       : Stack control
 * Z10 - Z13: Unallocated
 * Z14      : Debugger control
 * Z15      : PC
 */
/* Architecture mapping */
/* x86_64 (64-bit) */
 // Registers
 // Mnemonics
 // Value
/* Z# Virtual registers */
/* System call registers */
// ...
// clang-format off
# Allocate N bytes ‚Üí result in %rax
.macro MALLOC size
 SAVE_ZASM
 mov x0, "EVAL(SYS_GET(SYSCALL_MMAP))" ;// syscall number: mmap (Linux AArch64)
 mov x5, "EVAL(0)" ;// addr = NULL
 mov x4, "EVAL(\size)" ;// length = size
 mov x3, "EVAL(3)" ;// PROT_READ | PROT_WRITE
 mov x10, "EVAL(0x22)" ;// MAP_ANONYMOUS | MAP_PRIVATE
 mov x8, "EVAL(-1)" ;// fd = -1
 mov "EVAL(0)", x9 ;// offset = 0
 svc 0
 LOAD_ZASM
.endm
# Read value at pointer ‚Üí %reg
# ptr = register with pointer
# reg = output register
.macro PTR_READ ptr, reg
    mov [\ptr], \reg
.endm
# Write value to pointer
# value = register with value
# ptr = pointer register
.macro PTR_WRITE value, ptr
    mov \value, [\ptr]
.endm
# Store value in memory, and return a pointer to it
# value = register with value
# out = output register with pointer
.macro PTR_CREATE value, size, out
    SAVE_R0_R4
    MALLOC \size ;// allocate bytes
    mov \value, [x0] ;// store value at allocated address
    mov x0, \out ;// return pointer
    LOAD_R0_R4
.endm
.macro LEN ptr, out
 SAVE_R0_R4
 mov \ptr, x2
1:
 mov [x2], x3
 cmp x3, "EVAL(0)"
 b.eq 2f
 add x2, x2, "EVAL(1)"
 b 1b
2:
 mov x2, \out
 LOAD_R0_R4
.endm
.macro FREE ptr, size
 SAVE
 mov "EVAL(11)", x0 ;// sys_munmap
 mov \ptr, x5 ;// pointer
 mov "EVAL(\size)", x4 ;// size in bytes
 svc 0
 LOAD
.endm
.macro DEBUG value
 mov x2, "EVAL(\value)"
 LEN \value
 sub x3, x3, x2
.endm
 .arch armv8-a
 .file "pre_memory.hpp"
 .text
 .align 2
 .global _ZN6System9call_implEiz
 .type _ZN6System9call_implEiz, %function
_ZN6System9call_implEiz:
.LFB4:
 .cfi_startproc
 sub sp, sp, #304
 .cfi_def_cfa_offset 304
 str w0, [sp, 12]
 str x1, [sp, 248]
 str x2, [sp, 256]
 str x3, [sp, 264]
 str x4, [sp, 272]
 str x5, [sp, 280]
 str x6, [sp, 288]
 str x7, [sp, 296]
 str q0, [sp, 112]
 str q1, [sp, 128]
 str q2, [sp, 144]
 str q3, [sp, 160]
 str q4, [sp, 176]
 str q5, [sp, 192]
 str q6, [sp, 208]
 str q7, [sp, 224]
 adrp x0, :got:__stack_chk_guard;ldr x0, [x0, :got_lo12:__stack_chk_guard]
 ldr x1, [x0]
 str x1, [sp, 104]
 mov x1, 0
 add x0, sp, 304
 str x0, [sp, 72]
 add x0, sp, 304
 str x0, [sp, 80]
 add x0, sp, 240
 str x0, [sp, 88]
 mov w0, -56
 str w0, [sp, 96]
 mov w0, -128
 str w0, [sp, 100]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L2
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L3
.L2:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L4
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L3
.L4:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L3:
 ldr x0, [x0]
 str x0, [sp, 16]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L6
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L7
.L6:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L8
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L7
.L8:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L7:
 ldr x0, [x0]
 str x0, [sp, 24]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L10
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L11
.L10:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L12
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L11
.L12:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L11:
 ldr x0, [x0]
 str x0, [sp, 32]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L14
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L15
.L14:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L16
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L15
.L16:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L15:
 ldr x0, [x0]
 str x0, [sp, 40]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L18
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L19
.L18:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L20
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L19
.L20:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L19:
 ldr x0, [x0]
 str x0, [sp, 48]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L22
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L23
.L22:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L24
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L23
.L24:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L23:
 ldr x0, [x0]
 str x0, [sp, 56]
 ldrsw x1, [sp, 12]
 ldr x2, [sp, 16]
 ldr x6, [sp, 24]
 ldr x7, [sp, 32]
 ldr x11, [sp, 40]
 ldr x12, [sp, 48]
 ldr x13, [sp, 56]
#APP
// 83 "dist/compiled/pre_memory.hpp" 1
 mov x1, %rax
mov x2, %rdi
mov x6, %rsi
mov x7, %rdx
mov x11, %r10
mov x12, %r8
mov x13, %r9
syscall
mov %rax, x1
// 0 "" 2
#NO_APP
 str x1, [sp, 64]
 brk #1000
 .cfi_endproc
.LFE4:
 .size _ZN6System9call_implEiz, .-_ZN6System9call_implEiz
 .align 2
 .global _ZN6Memory8allocateEv
 .type _ZN6Memory8allocateEv, %function
_ZN6Memory8allocateEv:
.LFB5:
 .cfi_startproc
#APP
// 105 "dist/compiled/pre_memory.hpp" 1
 mov rdi, r8
call allocate_impl
mov rbp, rax
ret
// 0 "" 2
#NO_APP
 brk #1000
 .cfi_endproc
.LFE5:
 .size _ZN6Memory8allocateEv, .-_ZN6Memory8allocateEv
 .align 2
 .global _ZN6Memory13allocate_implEi
 .type _ZN6Memory13allocate_implEi, %function
_ZN6Memory13allocate_implEi:
.LFB6:
 .cfi_startproc
 stp x29, x30, [sp, -32]!
 .cfi_def_cfa_offset 32
 .cfi_offset 29, -32
 .cfi_offset 30, -24
 mov x29, sp
 str w0, [sp, 28]
 ldr w1, [sp, 28]
 mov w0, 9
 bl _ZN6System9call_implEiz
 brk #1000
 .cfi_endproc
.LFE6:
 .size _ZN6Memory13allocate_implEi, .-_ZN6Memory13allocate_implEi
 .ident "GCC: (Ubuntu 14.3.0-1ubuntu1) 14.3.0"
 .section .note.GNU-stack,"",@progbits
# Usage:
# STRUCT name
# STRUCT_FIELD field_name, size
# STRUCT_END
.set STRUCT_OFFSET, 0
.macro STRUCT name
 .set \name\()_SIZE, 0
 .pushsection .data
\name:
.endm
.macro STRUCT_FIELD name, size
\name:
 .skip \size
 .set STRUCT_OFFSET, STRUCT_OFFSET + \size
.endm
.macro STRUCT_END
 .popsection
 .set STRUCT_SIZE, STRUCT_OFFSET
 .set STRUCT_OFFSET, 0
.endm
.macro ALIGN boundary
 .balign \boundary
.endm
.macro VAR id, value, out
 ;// TODO
.endm
.macro FUNC name, _
 .section .text
 .global \name
\name:
.endm
.macro PARAM type, name
 # Store param info
 .quad 0x10
 .asciz "\name"
 .quad \type
.endm
.macro PARAMS_END
 .quad 0x11
.endm
.macro FUNC_END
 .quad 0xFF
.endm
.macro RETURN value
 mov bp, \value
.endm
 .arch armv8-a
 .file "pre_memory.hpp"
 .text
 .align 2
 .global _ZN6System9call_implEiz
 .type _ZN6System9call_implEiz, %function
_ZN6System9call_implEiz:
.LFB4:
 .cfi_startproc
 sub sp, sp, #304
 .cfi_def_cfa_offset 304
 str w0, [sp, 12]
 str x1, [sp, 248]
 str x2, [sp, 256]
 str x3, [sp, 264]
 str x4, [sp, 272]
 str x5, [sp, 280]
 str x6, [sp, 288]
 str x7, [sp, 296]
 str q0, [sp, 112]
 str q1, [sp, 128]
 str q2, [sp, 144]
 str q3, [sp, 160]
 str q4, [sp, 176]
 str q5, [sp, 192]
 str q6, [sp, 208]
 str q7, [sp, 224]
 adrp x0, :got:__stack_chk_guard;ldr x0, [x0, :got_lo12:__stack_chk_guard]
 ldr x1, [x0]
 str x1, [sp, 104]
 mov x1, 0
 add x0, sp, 304
 str x0, [sp, 72]
 add x0, sp, 304
 str x0, [sp, 80]
 add x0, sp, 240
 str x0, [sp, 88]
 mov w0, -56
 str w0, [sp, 96]
 mov w0, -128
 str w0, [sp, 100]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L2
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L3
.L2:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L4
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L3
.L4:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L3:
 ldr x0, [x0]
 str x0, [sp, 16]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L6
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L7
.L6:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L8
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L7
.L8:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L7:
 ldr x0, [x0]
 str x0, [sp, 24]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L10
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L11
.L10:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L12
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L11
.L12:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L11:
 ldr x0, [x0]
 str x0, [sp, 32]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L14
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L15
.L14:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L16
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L15
.L16:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L15:
 ldr x0, [x0]
 str x0, [sp, 40]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L18
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L19
.L18:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L20
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L19
.L20:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L19:
 ldr x0, [x0]
 str x0, [sp, 48]
 ldr w1, [sp, 96]
 ldr x0, [sp, 72]
 cmp w1, 0
 blt .L22
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L23
.L22:
 add w2, w1, 8
 str w2, [sp, 96]
 ldr w2, [sp, 96]
 cmp w2, 0
 ble .L24
 add x1, x0, 15
 and x1, x1, -8
 str x1, [sp, 72]
 b .L23
.L24:
 ldr x2, [sp, 80]
 sxtw x0, w1
 add x0, x2, x0
.L23:
 ldr x0, [x0]
 str x0, [sp, 56]
 ldrsw x1, [sp, 12]
 ldr x2, [sp, 16]
 ldr x6, [sp, 24]
 ldr x7, [sp, 32]
 ldr x11, [sp, 40]
 ldr x12, [sp, 48]
 ldr x13, [sp, 56]
#APP
// 83 "dist/compiled/pre_memory.hpp" 1
 mov x1, %rax
mov x2, %rdi
mov x6, %rsi
mov x7, %rdx
mov x11, %r10
mov x12, %r8
mov x13, %r9
syscall
mov %rax, x1
// 0 "" 2
#NO_APP
 str x1, [sp, 64]
 brk #1000
 .cfi_endproc
.LFE4:
 .size _ZN6System9call_implEiz, .-_ZN6System9call_implEiz
 .align 2
 .global _ZN6Memory8allocateEv
 .type _ZN6Memory8allocateEv, %function
_ZN6Memory8allocateEv:
.LFB5:
 .cfi_startproc
#APP
// 105 "dist/compiled/pre_memory.hpp" 1
 mov rdi, r8
call allocate_impl
mov rbp, rax
ret
// 0 "" 2
#NO_APP
 brk #1000
 .cfi_endproc
.LFE5:
 .size _ZN6Memory8allocateEv, .-_ZN6Memory8allocateEv
 .align 2
 .global _ZN6Memory13allocate_implEi
 .type _ZN6Memory13allocate_implEi, %function
_ZN6Memory13allocate_implEi:
.LFB6:
 .cfi_startproc
 stp x29, x30, [sp, -32]!
 .cfi_def_cfa_offset 32
 .cfi_offset 29, -32
 .cfi_offset 30, -24
 mov x29, sp
 str w0, [sp, 28]
 ldr w1, [sp, 28]
 mov w0, 9
 bl _ZN6System9call_implEiz
 brk #1000
 .cfi_endproc
.LFE6:
 .size _ZN6Memory13allocate_implEi, .-_ZN6Memory13allocate_implEi
 .ident "GCC: (Ubuntu 14.3.0-1ubuntu1) 14.3.0"
 .section .note.GNU-stack,"",@progbits
# Type initialization
.macro TYPE name
 STRUCT \name
.endm
.macro TYPE_FIELD type, name
  STRUCT_FIELD \name
.endm
.macro TYPE_END
 STRUCT_END
.endm
.macro SCOPE name
.endm
.macro SCOPE_SET name, value
.endm
.section .text
.global _start
_start:
// clang-format off
