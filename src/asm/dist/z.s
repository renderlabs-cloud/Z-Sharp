/* Copyright (C) 1991-2025 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */
/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */
/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */
/* wchar_t uses Unicode 10.0.0.  Version 10.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2017, fifth edition, plus
   the following additions from Amendment 1 to the fifth edition:
   - 56 emoji characters
   - 285 hentaigana
   - 3 additional Zanabazar Square characters */
/**
 * ! READ THIS !
 *
 * # Legal statements
 *
 * This code was generated by the Z# programming system. ü´é ‚ù§Ô∏è
 *
 * Z# is an open-source project licensed under the MIT License
 * with the following restriction:
 *
 * - You may use, copy, modify, merge, publish, distribute, and sublicense
 *   this software freely, **but you may NOT sell the original software
 *   or derivative works as standalone products.**
 *
 * - This software is provided "AS IS", without warranty of any kind.
 *
 * - The Z# organization, its developers, and contributors disclaim all liability
 *   for any damages arising from the use of this software.
 *
 * - Responsibility for malicious or harmful code lies solely with the author,
 *   not with Z# or its maintainers.
 *
 * Z# is not intended to generate malicious code, but like any tool,
 * it can be misused. Use at your own risk.
 *
 * If you find Z# useful, please consider supporting the project:
 * https://zsharp.dev/donate ‚ù§Ô∏è
 */
/**
 * # Register usage
 *
 * Z0 - Z4  : Mnemonic control
 * Z5       : Scope
 * Z6       : Selector control
 * Z7       : Parameters
 * Z8       : Control flow
 * Z9       : Stack control
 * Z10 - Z13: Unallocated
 * Z14      : Debugger control
 * Z15      : Temporary
 */
/* Architecture mapping */
/* x86_64 (64-bit) */
 # Registers
 # Mnemonics
 # Value
/* Z# Virtual registers */
.macro SAVE_R0_R4
 str x0, [sp, #-16]!
 str x1, [sp, #-16]!
 str x2, [sp, #-16]!
 str x3, [sp, #-16]!
 str x4, [sp, #-16]!
.endm
.macro LOAD_R0_R4
 ldr x4, [sp], #16
 ldr x3, [sp], #16
 ldr x2, [sp], #16
 ldr x1, [sp], #16
 ldr x0, [sp], #16
.endm
.macro SAVE_ZASM
 str x5, [sp, #-16]!
 str sp, [sp, #-16]!
 str x29, [sp, #-16]!
 str x8, [sp, #-16]!
 str x9, [sp, #-16]!
 str x10, [sp, #-16]!
 str x11, [sp, #-16]!
 str x12, [sp, #-16]!
 str x13, [sp, #-16]!
 str x14, [sp, #-16]!
 str x15, [sp, #-16]!
.endm
.macro LOAD_ZASM
 ldr x15, [sp], #16
 ldr x14, [sp], #16
 ldr x13, [sp], #16
 ldr x12, [sp], #16
 ldr x11, [sp], #16
 ldr x10, [sp], #16
 ldr x9, [sp], #16
 ldr x8, [sp], #16
 ldr x29, [sp], #16
 ldr sp, [sp], #16
 ldr x5, [sp], #16
.endm
.macro SAVE
 SAVE_R0_R4
 SAVE_ZASM
.endm
.macro LOAD
 LOAD_ZASM
 LOAD_R0_R4
.endm
# Allocate N bytes ‚Üí result in %rax
.macro MALLOC size
 SAVE_ZASM
 mov x0, #9 ;// syscall number: mmap (Linux AArch64)
 mov x5, #0 ;// addr = NULL
 mov x4, #\size ;// length = size
 mov x3, #3 ;// PROT_READ | PROT_WRITE
 mov x10, #0x22 ;// MAP_ANONYMOUS | MAP_PRIVATE
 mov x8, #-1 ;// fd = -1
 mov #0, x9 ;// offset = 0
 svc 0
 LOAD_ZASM
.endm
# Read value at pointer ‚Üí %reg
# ptr = register with pointer
# reg = output register
.macro PTR_READ ptr, reg
    mov [\ptr], \reg
.endm
# Write value to pointer
# value = register with value
# ptr = pointer register
.macro PTR_WRITE value, ptr
    mov \value, [\ptr]
.endm
# Store value in memory, and return a pointer to it
# value = register with value
# out = output register with pointer
.macro PTR_CREATE value, size, out
    SAVE_R0_R4
    MALLOC \size ;// allocate bytes
    mov \value, [x0] ;// store value at allocated address
    mov x0, \out ;// return pointer
    LOAD_R0_R4
.endm
.macro LEN ptr, out
 SAVE_R0_R4
 mov \ptr, x2
1:
 mov [x2], x3
 cmp x3, #0
 b.eq 2f
 add x2, x2, #1
 b 1b
2:
 mov x2, \out
 LOAD_R0_R4
.endm
.macro FREE ptr, size
 SAVE
 mov #11, x0 ;// sys_munmap
 mov \ptr, x5 ;// pointer
 mov #\size, x4 ;// size in bytes
 svc 0
 LOAD
.endm
.macro DEBUG value
 mov x2, #\value
 LEN \value
 sub x3, x3, x2
.endm
.section .text
.global _start
_start:
# Allocate the table itself once
.macro LAZY_LIST_INIT name, slots
    .lcomm \name, \slots * 8
.endm
# Get address of list[index] ‚Üí in %rdi
.macro LAZY_PTR_GET name, index, reg
 SAVE
 adr \name, \reg
 mov #\index, x4
 mul #8, #8, x4
 add x4, x4, \reg
 LOAD
.endm
# Access item at index, allocate if null
# name = list name
# index = integer index
# size = allocation size
# reg = register for result address
.macro LAZY_BLOCK_GET name, index, size, reg
 SAVE
 LAZY_PTR_GET \name, \index, \reg
 mov (\reg), x4
 b.ne #1f
 MALLOC \size
 mov x0, \reg
1:
 ldr \reg, [\reg, 0]
 LOAD
.endm
# Set value at a specific index in a lazy list
# name = list name
# index = integer index
# value = value to set (in register)
.macro LAZY_BLOCK_SET name, index, value
 SAVE
 LAZY_PTR_GET \name, \index, x5
 mov #\value, x5
 LOAD
.endm
# Usage:
# STRUCT name
# STRUCT_FIELD field_name, size
# STRUCT_END
.set STRUCT_OFFSET, 0
.macro STRUCT name
 .set \name\()_SIZE, 0
 .pushsection .data
\name:
.endm
.macro STRUCT_FIELD name, size
\name:
 .skip \size
 .set STRUCT_OFFSET, STRUCT_OFFSET + \size
.endm
.macro STRUCT_END
 .popsection
 .set STRUCT_SIZE, STRUCT_OFFSET
 .set STRUCT_OFFSET, 0
.endm
.macro ALIGN boundary
 .balign \boundary
.endm
.macro VAR id, value, out
 ;// TODO
.endm
.macro FUNC name, _
 .section .text
 .global \name
\name:
.endm
.macro PARAM type, name
 # Store param info
 .quad 0x10
 .asciz "\name"
 .quad \type
.endm
.macro PARAMS_END
 .quad 0x11
.endm
.macro FUNC_END
 .quad 0xFF
.endm
.macro RETURN value
 mov x8, \value
.endm
# Type initialization
.macro TYPE name
 STRUCT \name
.endm
.macro TYPE_FIELD type, name
  STRUCT_FIELD \name
.endm
.macro TYPE_END
 STRUCT_END
.endm
.macro SCOPE name
.endm
.macro SCOPE_SET name, value
.endm
