/* Copyright (C) 1991-2024 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */
/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */
/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */
/* wchar_t uses Unicode 10.0.0.  Version 10.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2017, fifth edition, plus
   the following additions from Amendment 1 to the fifth edition:
   - 56 emoji characters
   - 285 hentaigana
   - 3 additional Zanabazar Square characters */
/*
 * This code was generated by the Z# programming system.
 *
 * Z# is an open-source community project. By using Z#, you acknowledge and agree:
 *
 * - You trust the code you are running.
 * - You may not hold the Z# organization, its developers, or contributors liable
 *   for any damage caused by the code, even if it behaves maliciously.
 * - Responsibility for malicious or harmful behavior lies solely with the author
 *   of the code, not with Z# or its maintainers.
 *
 * Z# is not designed to generate malicious code, but like any programming tool,
 * it can be used to write harmful or unsafe programs.
 *
 * If you find Z# useful, please consider supporting the project:
 * https://zsharp.dev/donate
 *
 * Use at your own risk.
 */
/*
 * R0 - R4 : Mnemonic control
 * R5      : Scope
 * R6      : Selector control
 * R7      : Parameter control
 * R8      : Stack
 * R9 - R14: Unallocated
 * R15     : Temporary
 */
# Architecture mapping
/* x86_64 (64-bit) */
    # Registers
    # Mnemonics
        MUL x15, y, z
    # Value
# Usage:
# STRUCT name
# STRUCT_FIELD field_name, size
# STRUCT_END
.set STRUCT_OFFSET, 0
.macro STRUCT name
    .set \name\()_SIZE, 0
    .pushsection .data
\name:
.endm
.macro STRUCT_FIELD name, size
\name:
    .skip \size
    .set STRUCT_OFFSET, STRUCT_OFFSET + \size
.endm
.macro STRUCT_END
    .popsection
    .set STRUCT_SIZE, STRUCT_OFFSET
    .set STRUCT_OFFSET, 0
.endm
.macro ALIGN boundary
    .balign \boundary
.endm
# Allocate N bytes → result in %rax
.macro MALLOC size
    mov x0, #9 ;// sys_mmap
    eor x5, x5, x5 ;// NULL address
    mov x4, #\size ;// size in bytes
    mov x0, #3 ;// PROT_READ | PROT_WRITE
    mov x10, #34 ;// MAP_PRIVATE | MAP_ANONYMOUS
    eor x8, x8, x8 ;// fd = -1
    eor x9, x9, x9 ;// offset
    svc 0 ;// -> %rax = allocated pointer
.endm
# Read value at pointer → %reg
# ptr = register with pointer
# reg = output register
.macro PTR_READ ptr, reg
    mov \reg, (\ptr)
.endm
# Write value to pointer
# value = register with value
# ptr = pointer register
.macro PTR_WRITE value, ptr
    mov (\ptr), \value
.endm
# Store value in memory, and return a pointer to it
# value = register with value
# out = output register with pointer
.macro PTR_CREATE value, out
    MALLOC 8 ;// allocate 8 bytes
    mov (x0), \value ;// store value at allocated address
    mov \out, x0 ;// return pointer
.endm
# Optional, depending on the environment
.macro FREE ptr, size
    mov x0, #11 ;// sys_munmap
    mov x5, #\ptr ;// pointer
    mov x4, #\size ;// size in bytes
    svc 0
.endm
# Allocate the table itself once
.macro LAZY_LIST_INIT name, slots
    .lcomm \name, \slots * 8
.endm
# Get address of list[index] → in %rdi
.macro LAZY_PTR_GET name, index, reg
    adr \reg, \name
    mov x4, #\index
    mov x15, #8
    add x4, x4, \reg
.endm
# Access item at index, allocate if null
# name = list name
# index = integer index
# size = allocation size
# reg = register for result address
.macro LAZY_BLOCK_GET name, index, size, reg
    LAZY_PTR_GET \name, \index, \reg
    mov x4, (\reg)
   
    MALLOC \size
    mov \reg, x0
1:
    ldr \reg, [\reg]
.endm
# Set value at a specific index in a lazy list
# name = list name
# index = integer index
# value = value to set (in register)
.macro LAZY_BLOCK_SET name, index, value
    LAZY_PTR_GET \name, \index, x5
    mov x5, #\value
.endm
# Type initialization
.macro TYPE name
    STRUCT \name
.endm
.macro TYPE_FIELD type, name, size
        STRUCT_FIELD \name, \size
.endm
.macro TYPE_END
    STRUCT_END
.endm
.macro DEBUG value
    mov x0, #1 ;// sys_write system call
    mov x5, #1 ;// stdout file descriptor
    mov x4, \value ;// pointer to the string
    mov x3, #10 ;// length of the string
    svc 0
.endm
.macro STRING name, string
 .section data
  \name: .asciz \string
 .section text
.endm
TYPE Person
    TYPE_FIELD BYTE, name, 32
    TYPE_FIELD BYTE, id, 1
TYPE_END
LAZY_LIST_INIT my_list, 10
# LAZY_BLOCK_GET my_list, 5, 8, x15
LAZY_BLOCK_SET my_list, 5, 100
# DEBUG x15
